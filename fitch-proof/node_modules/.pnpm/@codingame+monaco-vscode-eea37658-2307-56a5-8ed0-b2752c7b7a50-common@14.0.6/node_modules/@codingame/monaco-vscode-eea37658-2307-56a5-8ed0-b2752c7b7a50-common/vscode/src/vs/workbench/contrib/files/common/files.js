
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { EditorResourceAccessor, SideBySideEditor } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { FileChangeType } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { RawContextKey, ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { Disposable, MutableDisposable, DisposableStore } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { IModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/model';
import { ILanguageService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/language';
import { ITextFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { InputFocusedContextKey } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkeys';
import { Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';

var TextFileContentProvider_1;
const VIEWLET_ID = 'workbench.view.explorer';
const VIEW_ID = 'workbench.explorer.fileView';
const ExplorerViewletVisibleContext = ( new RawContextKey(
    'explorerViewletVisible',
    true,
    { type: 'boolean', description: ( localize(6858, "True when the EXPLORER viewlet is visible.")) }
));
const FoldersViewVisibleContext = ( new RawContextKey('foldersViewVisible', true, { type: 'boolean', description: ( localize(
    6859,
    "True when the FOLDERS view (the file tree within the explorer view container) is visible."
)) }));
const ExplorerFolderContext = ( new RawContextKey(
    'explorerResourceIsFolder',
    false,
    { type: 'boolean', description: ( localize(6860, "True when the focused item in the EXPLORER is a folder.")) }
));
const ExplorerResourceReadonlyContext = ( new RawContextKey(
    'explorerResourceReadonly',
    false,
    { type: 'boolean', description: ( localize(6861, "True when the focused item in the EXPLORER is read-only.")) }
));
const ExplorerResourceWritableContext = ( ExplorerResourceReadonlyContext.toNegated());
const ExplorerResourceParentReadOnlyContext = ( new RawContextKey(
    'explorerResourceParentReadonly',
    false,
    { type: 'boolean', description: ( localize(6862, "True when the focused item in the EXPLORER's parent is read-only.")) }
));
const ExplorerResourceAvailableEditorIdsContext = ( new RawContextKey('explorerResourceAvailableEditorIds', ''));
const ExplorerRootContext = ( new RawContextKey(
    'explorerResourceIsRoot',
    false,
    { type: 'boolean', description: ( localize(6863, "True when the focused item in the EXPLORER is a root folder.")) }
));
const ExplorerResourceCut = ( new RawContextKey(
    'explorerResourceCut',
    false,
    { type: 'boolean', description: ( localize(6864, "True when an item in the EXPLORER has been cut for cut and paste.")) }
));
const ExplorerResourceMoveableToTrash = ( new RawContextKey(
    'explorerResourceMoveableToTrash',
    false,
    { type: 'boolean', description: ( localize(6865, "True when the focused item in the EXPLORER can be moved to trash.")) }
));
const FilesExplorerFocusedContext = ( new RawContextKey('filesExplorerFocus', true, { type: 'boolean', description: ( localize(6866, "True when the focus is inside the EXPLORER view.")) }));
const OpenEditorsFocusedContext = ( new RawContextKey('openEditorsFocus', true, { type: 'boolean', description: ( localize(6867, "True when the focus is inside the OPEN EDITORS view.")) }));
const ExplorerFocusedContext = ( new RawContextKey(
    'explorerViewletFocus',
    true,
    { type: 'boolean', description: ( localize(6868, "True when the focus is inside the EXPLORER viewlet.")) }
));
const ExplorerFindProviderActive = ( new RawContextKey(
    'explorerFindProviderActive',
    false,
    { type: 'boolean', description: ( localize(6869, "True when the explorer tree is using the explorer find provider.")) }
));
const ExplorerCompressedFocusContext = ( new RawContextKey(
    'explorerViewletCompressedFocus',
    true,
    { type: 'boolean', description: ( localize(6870, "True when the focused item in the EXPLORER view is a compact item.")) }
));
const ExplorerCompressedFirstFocusContext = ( new RawContextKey(
    'explorerViewletCompressedFirstFocus',
    true,
    { type: 'boolean', description: ( localize(
        6871,
        "True when the focus is inside a compact item's first part in the EXPLORER view."
    )) }
));
const ExplorerCompressedLastFocusContext = ( new RawContextKey(
    'explorerViewletCompressedLastFocus',
    true,
    { type: 'boolean', description: ( localize(
        6872,
        "True when the focus is inside a compact item's last part in the EXPLORER view."
    )) }
));
const ViewHasSomeCollapsibleRootItemContext = ( new RawContextKey(
    'viewHasSomeCollapsibleItem',
    false,
    { type: 'boolean', description: ( localize(
        6873,
        "True when a workspace in the EXPLORER view has some collapsible root child."
    )) }
));
const FilesExplorerFocusCondition = ( ContextKeyExpr.and(
    FoldersViewVisibleContext,
    FilesExplorerFocusedContext,
    ContextKeyExpr.not(InputFocusedContextKey)
));
const ExplorerFocusCondition = ( ContextKeyExpr.and(
    FoldersViewVisibleContext,
    ExplorerFocusedContext,
    ContextKeyExpr.not(InputFocusedContextKey)
));
const TEXT_FILE_EDITOR_ID = 'workbench.editors.files.textFileEditor';
const FILE_EDITOR_INPUT_ID = 'workbench.editors.files.fileEditorInput';
const BINARY_FILE_EDITOR_ID = 'workbench.editors.files.binaryFileEditor';
const BINARY_TEXT_FILE_MODE = 'code-text-binary';
var SortOrder;
(function (SortOrder) {
    SortOrder["Default"] = "default";
    SortOrder["Mixed"] = "mixed";
    SortOrder["FilesFirst"] = "filesFirst";
    SortOrder["Type"] = "type";
    SortOrder["Modified"] = "modified";
    SortOrder["FoldersNestsFiles"] = "foldersNestsFiles";
})(SortOrder || (SortOrder = {}));
var UndoConfirmLevel;
(function (UndoConfirmLevel) {
    UndoConfirmLevel["Verbose"] = "verbose";
    UndoConfirmLevel["Default"] = "default";
    UndoConfirmLevel["Light"] = "light";
})(UndoConfirmLevel || (UndoConfirmLevel = {}));
var LexicographicOptions;
(function (LexicographicOptions) {
    LexicographicOptions["Default"] = "default";
    LexicographicOptions["Upper"] = "upper";
    LexicographicOptions["Lower"] = "lower";
    LexicographicOptions["Unicode"] = "unicode";
})(LexicographicOptions || (LexicographicOptions = {}));
let TextFileContentProvider = TextFileContentProvider_1 = class TextFileContentProvider extends Disposable {
    constructor(textFileService, fileService, languageService, modelService) {
        super();
        this.textFileService = textFileService;
        this.fileService = fileService;
        this.languageService = languageService;
        this.modelService = modelService;
        this.fileWatcherDisposable = this._register(( new MutableDisposable()));
    }
    static async open(resource, scheme, label, editorService, options) {
        await editorService.openEditor({
            original: { resource: TextFileContentProvider_1.resourceToTextFile(scheme, resource) },
            modified: { resource },
            label,
            options
        });
    }
    static resourceToTextFile(scheme, resource) {
        return resource.with({ scheme, query: JSON.stringify({ scheme: resource.scheme, query: resource.query }) });
    }
    static textFileToResource(resource) {
        const { scheme, query } = JSON.parse(resource.query);
        return resource.with({ scheme, query });
    }
    async provideTextContent(resource) {
        if (!resource.query) {
            return null;
        }
        const savedFileResource = TextFileContentProvider_1.textFileToResource(resource);
        const codeEditorModel = await this.resolveEditorModel(resource);
        if (!this.fileWatcherDisposable.value) {
            const disposables = ( new DisposableStore());
            this.fileWatcherDisposable.value = disposables;
            disposables.add(this.fileService.onDidFilesChange(changes => {
                if (changes.contains(savedFileResource, FileChangeType.UPDATED)) {
                    this.resolveEditorModel(resource, false );
                }
            }));
            if (codeEditorModel) {
                disposables.add(Event.once(codeEditorModel.onWillDispose)(() => this.fileWatcherDisposable.clear()));
            }
        }
        return codeEditorModel;
    }
    async resolveEditorModel(resource, createAsNeeded = true) {
        const savedFileResource = TextFileContentProvider_1.textFileToResource(resource);
        const content = await this.textFileService.readStream(savedFileResource);
        let codeEditorModel = this.modelService.getModel(resource);
        if (codeEditorModel) {
            this.modelService.updateModel(codeEditorModel, content.value);
        }
        else if (createAsNeeded) {
            const textFileModel = this.modelService.getModel(savedFileResource);
            let languageSelector;
            if (textFileModel) {
                languageSelector = this.languageService.createById(textFileModel.getLanguageId());
            }
            else {
                languageSelector = this.languageService.createByFilepathOrFirstLine(savedFileResource);
            }
            codeEditorModel = this.modelService.createModel(content.value, languageSelector, resource);
        }
        return codeEditorModel;
    }
};
TextFileContentProvider = TextFileContentProvider_1 = ( __decorate([
    ( __param(0, ITextFileService)),
    ( __param(1, IFileService)),
    ( __param(2, ILanguageService)),
    ( __param(3, IModelService))
], TextFileContentProvider));
class OpenEditor {
    static { this.COUNTER = 0; }
    constructor(_editor, _group) {
        this._editor = _editor;
        this._group = _group;
        this.id = OpenEditor.COUNTER++;
    }
    get editor() {
        return this._editor;
    }
    get group() {
        return this._group;
    }
    get groupId() {
        return this._group.id;
    }
    getId() {
        return `openeditor:${this.groupId}:${this.id}`;
    }
    isPreview() {
        return !this._group.isPinned(this.editor);
    }
    isSticky() {
        return this._group.isSticky(this.editor);
    }
    getResource() {
        return EditorResourceAccessor.getOriginalUri(this.editor, { supportSideBySide: SideBySideEditor.PRIMARY });
    }
}

export { BINARY_FILE_EDITOR_ID, BINARY_TEXT_FILE_MODE, ExplorerCompressedFirstFocusContext, ExplorerCompressedFocusContext, ExplorerCompressedLastFocusContext, ExplorerFindProviderActive, ExplorerFocusCondition, ExplorerFocusedContext, ExplorerFolderContext, ExplorerResourceAvailableEditorIdsContext, ExplorerResourceCut, ExplorerResourceMoveableToTrash, ExplorerResourceParentReadOnlyContext, ExplorerResourceReadonlyContext, ExplorerResourceWritableContext, ExplorerRootContext, ExplorerViewletVisibleContext, FILE_EDITOR_INPUT_ID, FilesExplorerFocusCondition, FilesExplorerFocusedContext, FoldersViewVisibleContext, LexicographicOptions, OpenEditor, OpenEditorsFocusedContext, SortOrder, TEXT_FILE_EDITOR_ID, TextFileContentProvider, UndoConfirmLevel, VIEWLET_ID, VIEW_ID, ViewHasSomeCollapsibleRootItemContext };
