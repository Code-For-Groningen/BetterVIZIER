
import { __decorate, __param } from '../../../../../../../../../external/tslib/tslib.es6.js';
import { $ } from '../../../../../../base/browser/dom.js';
import { Disposable } from '../../../../../../base/common/lifecycle.js';
import { observableValue } from '../../../../../../base/common/observableInternal/base.js';
import '../../../../../../base/common/arrays.js';
import '../../../../../../base/common/event.js';
import '../../../../../../base/common/observableInternal/autorun.js';
import { derived, derivedWithStore } from '../../../../../../base/common/observableInternal/derived.js';
import '../../../../../../base/common/cancellation.js';
import { constObservable } from '../../../../../../base/common/observableInternal/utils.js';
import { IInstantiationService } from '../../../../../../platform/instantiation/common/instantiation.js';
import { observableCodeEditor } from '../../../../../browser/observableCodeEditor.js';
import { Point } from '../../../../../browser/point.js';
import { RenderOptions, renderLines, LineSource } from '../../../../../browser/widget/diffEditor/components/diffEditorViewZones/renderLines.js';
import { EditorOption } from '../../../../../common/config/editorOptions.js';
import { LineRange } from '../../../../../common/core/lineRange.js';
import { Position } from '../../../../../common/core/position.js';
import { Range } from '../../../../../common/core/range.js';
import { ILanguageService } from '../../../../../common/languages/language.js';
import { LineTokens } from '../../../../../common/tokens/lineTokens.js';
import { TokenArray } from '../../../../../common/tokens/tokenArray.js';
import { GhostText, GhostTextPart } from '../../model/ghostText.js';
import { GhostTextView } from '../ghostText/ghostTextView.js';
import { n, mapOutFalsy, createRectangle } from './utils.js';

let InlineEditsInsertionView = class InlineEditsInsertionView extends Disposable {
    constructor(_editor, _input, _instantiationService, _languageService) {
        super();
        this._editor = _editor;
        this._input = _input;
        this._instantiationService = _instantiationService;
        this._languageService = _languageService;
        this._editorObs = observableCodeEditor(this._editor);
        this._state = derived(this, reader => {
            const state = this._input.read(reader);
            if (!state) {
                return undefined;
            }
            const textModel = this._editor.getModel();
            const eol = textModel.getEOL();
            if (state.startColumn === 1 && state.lineNumber > 1 && textModel.getLineLength(state.lineNumber) !== 0 && state.text.endsWith(eol) && !state.text.startsWith(eol)) {
                const endOfLineColumn = textModel.getLineLength(state.lineNumber - 1) + 1;
                return { lineNumber: state.lineNumber - 1, column: endOfLineColumn, text: eol + state.text.slice(0, -eol.length) };
            }
            return { lineNumber: state.lineNumber, column: state.startColumn, text: state.text };
        });
        this._ghostText = derived(reader => {
            const state = this._state.read(reader);
            if (!state) {
                return undefined;
            }
            return ( new GhostText(state.lineNumber, [( new GhostTextPart(state.column, state.text, false))]));
        });
        this._ghostTextView = this._register(this._instantiationService.createInstance(GhostTextView, this._editor, {
            ghostText: this._ghostText,
            minReservedLineCount: constObservable(0),
            targetTextModel: ( this._editorObs.model.map(model => model ?? undefined)),
        }, observableValue(this, { syntaxHighlightingEnabled: true, extraClasses: ['inline-edit'] }), true));
        this._display = derived(this, reader => !!this._state.read(reader) ? 'block' : 'none');
        this._editorMaxContentWidthInRange = derived(this, reader => {
            const state = this._state.read(reader);
            if (!state) {
                return 0;
            }
            this._editorObs.versionId.read(reader);
            const textModel = this._editor.getModel();
            const eol = textModel.getEOL();
            const textBeforeInsertion = state.text.startsWith(eol) ? '' : textModel.getValueInRange(( new Range(state.lineNumber, 1, state.lineNumber, state.column)));
            const textAfterInsertion = textModel.getValueInRange(( new Range(
                state.lineNumber,
                state.column,
                state.lineNumber,
                textModel.getLineLength(state.lineNumber) + 1
            )));
            const text = textBeforeInsertion + state.text + textAfterInsertion;
            const lines = text.split(eol);
            const renderOptions = RenderOptions.fromEditor(this._editor).withSetWidth(false);
            const lineWidths = ( lines.map(line => {
                const t = textModel.tokenization.tokenizeLinesAt(state.lineNumber, [line])?.[0];
                let tokens;
                if (t) {
                    tokens = TokenArray.fromLineTokens(t).toLineTokens(line, this._languageService.languageIdCodec);
                }
                else {
                    tokens = LineTokens.createEmpty(line, this._languageService.languageIdCodec);
                }
                return renderLines(( new LineSource([tokens])), renderOptions, [], $('div'), true).minWidthInPx - 20;
            }));
            return Math.max(...lineWidths);
        });
        this._trimVertically = derived(this, reader => {
            const text = this._state.read(reader)?.text;
            if (!text || text.trim() === '') {
                return { top: 0, bottom: 0 };
            }
            const lineHeight = this._editor.getOption(EditorOption.lineHeight);
            const eol = this._editor.getModel().getEOL();
            let topTrim = 0;
            let bottomTrim = 0;
            let i = 0;
            for (; i < text.length && text.startsWith(eol, i); i += eol.length) {
                topTrim += lineHeight;
            }
            for (let j = text.length; j > i && text.endsWith(eol, j); j -= eol.length) {
                bottomTrim += lineHeight;
            }
            return { top: topTrim, bottom: bottomTrim };
        });
        this.startLineOffset = ( this._trimVertically.map(v => v.top));
        this.originalLines = ( this._state.map(s => s ? ( new LineRange(s.lineNumber, s.lineNumber + 2)) : undefined));
        this._overlayLayout = derivedWithStore(this, (reader, store) => {
            this._ghostText.read(reader);
            const state = this._state.read(reader);
            if (!state) {
                return null;
            }
            this._editorObs.observePosition(observableValue(this, ( new Position(state.lineNumber, state.column))), store).read(reader);
            const editorLayout = this._editorObs.layoutInfo.read(reader);
            const horizontalScrollOffset = this._editorObs.scrollLeft.read(reader);
            const left = editorLayout.contentLeft + this._editorMaxContentWidthInRange.read(reader) - horizontalScrollOffset;
            const codeLeft = editorLayout.contentLeft;
            if (left <= codeLeft) {
                return null;
            }
            const { top: topTrim, bottom: bottomTrim } = this._trimVertically.read(reader);
            const scrollTop = this._editorObs.scrollTop.read(reader);
            const height = this._ghostTextView.height.read(reader) - topTrim - bottomTrim;
            const top = this._editor.getTopForLineNumber(state.lineNumber) - scrollTop + topTrim;
            const bottom = top + height;
            const code1 = ( new Point(left, top));
            const codeStart1 = ( new Point(codeLeft, top));
            const code2 = ( new Point(left, bottom));
            const codeStart2 = ( new Point(codeLeft, bottom));
            return {
                code1,
                codeStart1,
                code2,
                codeStart2,
                horizontalScrollOffset,
                padding: 3,
                borderRadius: 4,
            };
        }).recomputeInitiallyAndOnChange(this._store);
        this._foregroundSvg = n.svg({
            transform: 'translate(-0.5 -0.5)',
            style: { overflow: 'visible', pointerEvents: 'none', position: 'absolute' },
        }, derived(reader => {
            const overlayLayoutObs = mapOutFalsy(this._overlayLayout).read(reader);
            if (!overlayLayoutObs) {
                return undefined;
            }
            const layoutInfo = overlayLayoutObs.read(reader);
            const rectangleOverlay = createRectangle({
                topLeft: layoutInfo.codeStart1,
                width: layoutInfo.code1.x - layoutInfo.codeStart1.x + 1,
                height: layoutInfo.code2.y - layoutInfo.code1.y + 1,
            }, layoutInfo.padding, layoutInfo.borderRadius, { hideLeft: layoutInfo.horizontalScrollOffset !== 0 });
            return [
                n.svgElem('path', {
                    class: 'originalOverlay',
                    d: rectangleOverlay,
                    style: {
                        fill: 'var(--vscode-inlineEdit-modifiedChangedLineBackground, transparent)',
                        stroke: 'var(--vscode-inlineEdit-modifiedBorder)',
                        strokeWidth: '1px',
                    }
                }),
            ];
        })).keepUpdated(this._store);
        this._nonOverflowView = n.div({
            class: 'inline-edits-view',
            style: {
                position: 'absolute',
                overflow: 'visible',
                top: '0px',
                left: '0px',
                zIndex: '0',
                display: this._display,
            },
        }, [
            [this._foregroundSvg],
        ]).keepUpdated(this._store);
        this.isHovered = constObservable(false);
        this._register(this._editorObs.createOverlayWidget({
            domNode: this._nonOverflowView.element,
            position: constObservable(null),
            allowEditorOverflow: false,
            minContentWidthInPx: derived(reader => {
                const info = this._overlayLayout.read(reader);
                if (info === null) {
                    return 0;
                }
                return info.code1.x - info.codeStart1.x;
            }),
        }));
    }
};
InlineEditsInsertionView = ( __decorate([
    ( __param(2, IInstantiationService)),
    ( __param(3, ILanguageService))
], InlineEditsInsertionView));

export { InlineEditsInsertionView };
