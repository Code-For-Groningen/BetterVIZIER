
import { isDiffEditor, isCodeEditor } from '../../../../editor/browser/editorBrowser.js';
import { localize2, localize } from '../../../../nls.js';
import { EditorAction2 } from '../../../../editor/browser/editorExtensions.js';
import { Codicon } from '../../../../base/common/codicons.js';
import { Action2, MenuId, registerAction2, MenuRegistry } from '../../../../platform/actions/common/actions.js';
import { KeybindingWeight } from '../../../../platform/keybinding/common/keybindingsRegistry.js';
import { KeyMod as KeyMod$1, KeyCode } from '../../../../base/common/keyCodes.js';
import { CHAT_CATEGORY } from './actions/chatActions.js';
import { ctxReviewModeEnabled, ctxHasEditorModification, ChatEditorController } from './chatEditorController.js';
import { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';
import { EditorContextKeys } from '../../../../editor/common/editorContextKeys.js';
import { ACTIVE_GROUP } from '../../../services/editor/common/editorService.js';
import { IEditorService } from '../../../services/editor/common/editorService.service.js';
import { hasUndecidedChatEditingResourceContextKey } from '../common/chatEditingService.js';
import { IChatEditingService } from '../common/chatEditingService.service.js';
import { ChatContextKeys } from '../common/chatContextKeys.js';
import { isEqual } from '../../../../base/common/resources.js';
import { Range } from '../../../../editor/common/core/range.js';
import { getNotebookEditorFromEditorPane } from '../../notebook/browser/notebookBrowser.js';
import { ctxNotebookHasEditorModification } from '../../notebook/browser/contrib/chatEdit/notebookChatEditContext.js';

class NavigateAction extends Action2 {
    constructor(next) {
        super({
            id: next
                ? 'chatEditor.action.navigateNext'
                : 'chatEditor.action.navigatePrevious',
            title: next
                ? ( localize2(4506, 'Go to Next Chat Edit'))
                : ( localize2(4507, 'Go to Previous Chat Edit')),
            category: CHAT_CATEGORY,
            icon: next ? Codicon.arrowDown : Codicon.arrowUp,
            keybinding: {
                primary: next
                    ? KeyMod$1.Alt | KeyCode.F5
                    : KeyMod$1.Alt | KeyMod$1.Shift | KeyCode.F5,
                weight: KeybindingWeight.WorkbenchContrib,
                when: ( ContextKeyExpr.and(( ContextKeyExpr.or(ctxHasEditorModification, ctxNotebookHasEditorModification)), EditorContextKeys.focus)),
            },
            f1: true,
            menu: {
                id: MenuId.ChatEditingEditorContent,
                group: 'navigate',
                order: !next ? 2 : 3,
                when: ctxReviewModeEnabled
            }
        });
        this.next = next;
    }
    async run(accessor) {
        const chatEditingService = accessor.get(IChatEditingService);
        const editorService = accessor.get(IEditorService);
        let editor = editorService.activeTextEditorControl;
        if (isDiffEditor(editor)) {
            editor = editor.getModifiedEditor();
        }
        if (!isCodeEditor(editor) || !editor.hasModel()) {
            return;
        }
        const ctrl = ChatEditorController.get(editor);
        if (!ctrl) {
            return;
        }
        const session = chatEditingService.editingSessionsObs.get()
            .find(candidate => candidate.getEntry(editor.getModel().uri));
        if (!session) {
            return;
        }
        const done = this.next
            ? ctrl.revealNext(true)
            : ctrl.revealPrevious(true);
        if (done) {
            return;
        }
        const entries = session.entries.get();
        const idx = entries.findIndex(e => isEqual(e.modifiedURI, editor.getModel().uri));
        if (idx < 0) {
            return;
        }
        const newIdx = (idx + (this.next ? 1 : -1) + entries.length) % entries.length;
        if (idx === newIdx) {
            if (this.next) {
                ctrl.revealNext(false);
            }
            else {
                ctrl.revealPrevious(false);
            }
            return;
        }
        const entry = entries[newIdx];
        const change = entry.diffInfo.get().changes.at(this.next ? 0 : -1);
        const newEditorPane = await editorService.openEditor({
            resource: entry.modifiedURI,
            options: {
                selection: change && Range.fromPositions({ lineNumber: change.modified.startLineNumber, column: 1 }),
                revealIfOpened: false,
                revealIfVisible: false,
            }
        }, ACTIVE_GROUP);
        const newEditor = newEditorPane?.getControl();
        if (isCodeEditor(newEditor)) {
            ChatEditorController.get(newEditor)?.initNavigation();
        }
    }
}
class AcceptDiscardAction extends Action2 {
    constructor(id, accept) {
        super({
            id,
            title: accept
                ? ( localize2(4508, 'Accept Chat Edit'))
                : ( localize2(4509, 'Discard Chat Edit')),
            shortTitle: accept
                ? ( localize2(4510, 'Accept'))
                : ( localize2(4511, 'Discard')),
            category: CHAT_CATEGORY,
            precondition: ( ContextKeyExpr.and(ctxHasEditorModification, hasUndecidedChatEditingResourceContextKey)),
            icon: accept
                ? Codicon.check
                : Codicon.discard,
            f1: true,
            keybinding: {
                when: EditorContextKeys.focus,
                weight: KeybindingWeight.WorkbenchContrib,
                primary: accept
                    ? KeyMod$1.CtrlCmd | KeyCode.Enter
                    : KeyMod$1.CtrlCmd | KeyCode.Backspace
            },
            menu: {
                id: MenuId.ChatEditingEditorContent,
                group: 'a_resolve',
                order: accept ? 0 : 1,
                when: !accept ? ctxReviewModeEnabled : undefined
            }
        });
        this.accept = accept;
    }
    run(accessor) {
        const chatEditingService = accessor.get(IChatEditingService);
        const editorService = accessor.get(IEditorService);
        let uri = getNotebookEditorFromEditorPane(editorService.activeEditorPane)?.textModel?.uri;
        if (!uri) {
            let editor = editorService.activeTextEditorControl;
            if (isDiffEditor(editor)) {
                editor = editor.getModifiedEditor();
            }
            uri = isCodeEditor(editor) && editor.hasModel()
                ? editor.getModel().uri
                : undefined;
        }
        if (!uri) {
            return;
        }
        const session = chatEditingService.editingSessionsObs.get()
            .find(candidate => candidate.getEntry(uri));
        if (!session) {
            return;
        }
        if (this.accept) {
            session.accept(uri);
        }
        else {
            session.reject(uri);
        }
    }
}
class AcceptAction extends AcceptDiscardAction {
    static { this.ID = 'chatEditor.action.accept'; }
    constructor() {
        super(AcceptAction.ID, true);
    }
}
class RejectAction extends AcceptDiscardAction {
    static { this.ID = 'chatEditor.action.reject'; }
    constructor() {
        super(RejectAction.ID, false);
    }
}
class RejectHunkAction extends EditorAction2 {
    constructor() {
        super({
            id: 'chatEditor.action.undoHunk',
            title: ( localize2(4512, 'Discard this Change')),
            category: CHAT_CATEGORY,
            precondition: ( ContextKeyExpr.and(ctxHasEditorModification, ( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey)),
            icon: Codicon.discard,
            f1: true,
            keybinding: {
                when: EditorContextKeys.focus,
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod$1.CtrlCmd | KeyMod$1.Shift | KeyCode.Backspace
            },
            menu: {
                id: MenuId.ChatEditingEditorHunk,
                order: 1
            }
        });
    }
    runEditorCommand(_accessor, editor, ...args) {
        ChatEditorController.get(editor)?.rejectNearestChange(args[0]);
    }
}
class AcceptHunkAction extends EditorAction2 {
    constructor() {
        super({
            id: 'chatEditor.action.acceptHunk',
            title: ( localize2(4513, 'Accept this Change')),
            category: CHAT_CATEGORY,
            precondition: ( ContextKeyExpr.and(ctxHasEditorModification, ( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey)),
            icon: Codicon.check,
            f1: true,
            keybinding: {
                when: EditorContextKeys.focus,
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod$1.CtrlCmd | KeyMod$1.Shift | KeyCode.Enter
            },
            menu: {
                id: MenuId.ChatEditingEditorHunk,
                order: 0
            }
        });
    }
    runEditorCommand(_accessor, editor, ...args) {
        ChatEditorController.get(editor)?.acceptNearestChange(args[0]);
    }
}
class OpenDiffAction extends EditorAction2 {
    constructor() {
        super({
            id: 'chatEditor.action.diffHunk',
            title: ( localize2(4514, 'Toggle Diff Editor')),
            category: CHAT_CATEGORY,
            toggled: {
                condition: EditorContextKeys.inDiffEditor,
                icon: Codicon.goToFile,
            },
            precondition: ( ContextKeyExpr.and(ctxHasEditorModification, ( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey)),
            icon: Codicon.diffSingle,
            keybinding: {
                when: EditorContextKeys.focus,
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod$1.Alt | KeyMod$1.Shift | KeyCode.F7,
            },
            menu: [{
                    id: MenuId.ChatEditingEditorHunk,
                    order: 10
                }, {
                    id: MenuId.ChatEditingEditorContent,
                    group: 'a_resolve',
                    order: 2,
                    when: ctxReviewModeEnabled
                }]
        });
    }
    runEditorCommand(_accessor, editor, ...args) {
        ChatEditorController.get(editor)?.toggleDiff(args[0]);
    }
}
class ReviewChangesAction extends EditorAction2 {
    constructor() {
        super({
            id: 'chatEditor.action.reviewChanges',
            title: ( localize2(4515, "Review")),
            menu: [{
                    id: MenuId.ChatEditingEditorContent,
                    group: 'a_resolve',
                    order: 3,
                    when: ( ctxReviewModeEnabled.negate()),
                }]
        });
    }
    runEditorCommand(accessor, editor) {
        const chatEditingService = accessor.get(IChatEditingService);
        if (!editor.hasModel()) {
            return;
        }
        const session = chatEditingService.editingSessionsObs.get().find(session => session.getEntry(editor.getModel().uri));
        const entry = session?.getEntry(editor.getModel().uri);
        entry?.enableReviewModeUntilSettled();
    }
}
function registerChatEditorActions() {
    registerAction2(class NextAction extends NavigateAction {
        constructor() { super(true); }
    });
    registerAction2(class PrevAction extends NavigateAction {
        constructor() { super(false); }
    });
    registerAction2(ReviewChangesAction);
    registerAction2(AcceptAction);
    registerAction2(AcceptHunkAction);
    registerAction2(RejectAction);
    registerAction2(RejectHunkAction);
    registerAction2(OpenDiffAction);
    MenuRegistry.appendMenuItem(MenuId.ChatEditingEditorContent, {
        command: {
            id: navigationBearingFakeActionId,
            title: ( localize(4516, "Navigation Status")),
            precondition: ( ContextKeyExpr.false()),
        },
        group: 'navigate',
        order: -1,
        when: ctxReviewModeEnabled,
    });
}
const navigationBearingFakeActionId = 'chatEditor.navigation.bearings';

export { AcceptAction, RejectAction, ReviewChangesAction, navigationBearingFakeActionId, registerChatEditorActions };
