
import { Range } from '../core/range.js';
import { TokenStore } from './tokenStore.js';
import { registerSingleton, InstantiationType } from '../../../platform/instantiation/common/extensions.js';
import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';
import { DisposableStore } from '../../../base/common/lifecycle.js';

const ITreeSitterTokenizationStoreService = ( createDecorator('treeSitterTokenizationStoreService'));
class TreeSitterTokenizationStoreService {
    constructor() {
        this.tokens = ( new Map());
    }
    setTokens(model, tokens) {
        const disposables = ( new DisposableStore());
        const store = disposables.add(( new TokenStore(model)));
        this.tokens.set(model, { store: store, accurateVersion: model.getVersionId(), disposables, guessVersion: model.getVersionId() });
        store.buildStore(tokens);
        disposables.add(model.onDidChangeContent(e => {
            const storeInfo = this.tokens.get(model);
            if (!storeInfo) {
                return;
            }
            storeInfo.guessVersion = e.versionId;
            for (const change of e.changes) {
                if (change.text.length > change.rangeLength) {
                    const oldToken = storeInfo.store.getTokenAt(change.rangeOffset);
                    let newToken;
                    if (oldToken) {
                        newToken = { startOffsetInclusive: oldToken.startOffsetInclusive, length: oldToken.length + change.text.length - change.rangeLength, token: oldToken.token };
                    }
                    else {
                        newToken = { startOffsetInclusive: change.rangeOffset, length: change.text.length, token: 0 };
                    }
                    storeInfo.store.update(oldToken?.length ?? 0, [newToken], true);
                }
                else if (change.text.length < change.rangeLength) {
                    const deletedCharCount = change.rangeLength - change.text.length;
                    storeInfo.store.delete(deletedCharCount, change.rangeOffset);
                }
                const refreshLength = change.rangeLength > change.text.length ? change.rangeLength : change.text.length;
                storeInfo.store.markForRefresh(change.rangeOffset, change.rangeOffset + refreshLength);
            }
        }));
        disposables.add(model.onWillDispose(() => {
            const storeInfo = this.tokens.get(model);
            if (storeInfo) {
                storeInfo.disposables.dispose();
                this.tokens.delete(model);
            }
        }));
    }
    hasTokens(model, accurateForRange) {
        const tokens = this.tokens.get(model);
        if (!tokens) {
            return false;
        }
        if (!accurateForRange || (tokens.guessVersion === tokens.accurateVersion)) {
            return true;
        }
        return !tokens.store.rangeNeedsRefresh(model.getOffsetAt(accurateForRange.getStartPosition()), model.getOffsetAt(accurateForRange.getEndPosition()));
    }
    getTokens(model, line) {
        const tokens = this.tokens.get(model)?.store;
        if (!tokens) {
            return undefined;
        }
        const lineStartOffset = model.getOffsetAt({ lineNumber: line, column: 1 });
        const lineTokens = tokens.getTokensInRange(lineStartOffset, model.getOffsetAt({ lineNumber: line, column: model.getLineMaxColumn(line) }) + 1);
        const result = ( new Uint32Array(lineTokens.length * 2));
        for (let i = 0; i < lineTokens.length; i++) {
            result[i * 2] = lineTokens[i].startOffsetInclusive - lineStartOffset + lineTokens[i].length;
            result[i * 2 + 1] = lineTokens[i].token;
        }
        return result;
    }
    updateTokens(model, version, updates) {
        const existingTokens = this.tokens.get(model);
        if (!existingTokens) {
            return;
        }
        existingTokens.accurateVersion = version;
        for (const update of updates) {
            const lastToken = update.newTokens.length > 0 ? update.newTokens[update.newTokens.length - 1] : undefined;
            const oldRangeLength = ((existingTokens.guessVersion >= version) && lastToken) ? (lastToken.startOffsetInclusive + lastToken.length - update.newTokens[0].startOffsetInclusive) : update.oldRangeLength;
            existingTokens.store.update(oldRangeLength, update.newTokens);
        }
    }
    markForRefresh(model, range) {
        const tree = this.tokens.get(model)?.store;
        if (!tree) {
            return;
        }
        tree.markForRefresh(model.getOffsetAt(range.getStartPosition()), model.getOffsetAt(range.getEndPosition()));
    }
    getNeedsRefresh(model) {
        const needsRefreshOffsetRanges = this.tokens.get(model)?.store.getNeedsRefresh();
        if (!needsRefreshOffsetRanges) {
            return [];
        }
        return ( needsRefreshOffsetRanges.map(range => ({
            range: Range.fromPositions(model.getPositionAt(range.startOffset), model.getPositionAt(range.endOffset)),
            startOffset: range.startOffset,
            endOffset: range.endOffset
        })));
    }
    dispose() {
        for (const [, value] of this.tokens) {
            value.disposables.dispose();
        }
    }
}
registerSingleton(ITreeSitterTokenizationStoreService, TreeSitterTokenizationStoreService, InstantiationType.Delayed);

export { ITreeSitterTokenizationStoreService, TreeSitterTokenizationStoreService };
