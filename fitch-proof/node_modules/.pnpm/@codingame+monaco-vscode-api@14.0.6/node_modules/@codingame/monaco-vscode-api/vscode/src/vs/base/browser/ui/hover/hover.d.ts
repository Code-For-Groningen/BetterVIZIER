import type { IHoverDelegate } from "./hoverDelegate.js";
import type { HoverPosition } from "./hoverWidget.js";
import type { CancellationToken } from "../../../common/cancellation.js";
import type { IMarkdownString } from "../../../common/htmlContent.js";
import type { IDisposable } from "../../../common/lifecycle.js";
export interface IHoverDelegate2 {
    showHover(options: IHoverOptions, focus?: boolean): IHoverWidget | undefined;
    showDelayedHover(options: IHoverOptions, lifecycleOptions: Pick<IHoverLifecycleOptions, "groupId">): IHoverWidget | undefined;
    setupDelayedHover(target: HTMLElement, hoverOptions: (() => IDelayedHoverOptions) | IDelayedHoverOptions, lifecycleOptions?: IHoverLifecycleOptions): IDisposable;
    setupDelayedHoverAtMouse(target: HTMLElement, hoverOptions: (() => IDelayedHoverAtMouseOptions) | IDelayedHoverAtMouseOptions, lifecycleOptions?: IHoverLifecycleOptions): IDisposable;
    hideHover(): void;
    showAndFocusLastHover(): void;
    setupManagedHover(hoverDelegate: IHoverDelegate, targetElement: HTMLElement, content: IManagedHoverContentOrFactory, options?: IManagedHoverOptions): IManagedHover;
    showManagedHover(targetElement: HTMLElement): void;
}
export interface IHoverWidget extends IDisposable {
    readonly isDisposed: boolean;
}
export interface IHoverOptions {
    content: IMarkdownString | string | HTMLElement;
    target: IHoverTarget | HTMLElement;
    container?: HTMLElement;
    id?: string;
    actions?: IHoverAction[];
    additionalClasses?: string[];
    linkHandler?(url: string): void;
    trapFocus?: boolean;
    position?: IHoverPositionOptions;
    persistence?: IHoverPersistenceOptions;
    appearance?: IHoverAppearanceOptions;
}
export type IDelayedHoverOptions = Omit<IHoverOptions, "target">;
export type IDelayedHoverAtMouseOptions = Omit<IDelayedHoverOptions, "position" | "appearance"> & {
    appearance?: Omit<IHoverAppearanceOptions, "showPointer">;
};
export interface IHoverLifecycleOptions {
    groupId?: string;
    setupKeyboardEvents?: boolean;
}
export interface IHoverPositionOptions {
    hoverPosition?: HoverPosition | MouseEvent;
    forcePosition?: boolean;
}
export interface IHoverPersistenceOptions {
    hideOnHover?: boolean;
    hideOnKeyDown?: boolean;
    sticky?: boolean;
}
export interface IHoverAppearanceOptions {
    showPointer?: boolean;
    compact?: boolean;
    showHoverHint?: boolean;
    skipFadeInAnimation?: boolean;
}
export interface IHoverAction {
    label: string;
    commandId: string;
    iconClass?: string;
    run(target: HTMLElement): void;
}
export interface IHoverTarget extends Partial<IDisposable> {
    readonly targetElements: readonly HTMLElement[];
    readonly x?: number;
    readonly y?: number;
}
export interface IManagedHoverTooltipMarkdownString {
    markdown: IMarkdownString | string | undefined | ((token: CancellationToken) => Promise<IMarkdownString | string | undefined>);
    markdownNotSupportedFallback: string | undefined;
}
export type IManagedHoverContent = string | IManagedHoverTooltipMarkdownString | HTMLElement | undefined;
export type IManagedHoverContentOrFactory = IManagedHoverContent | (() => IManagedHoverContent);
export interface IManagedHoverOptions extends Pick<IHoverOptions, "actions" | "linkHandler" | "trapFocus"> {
    appearance?: Pick<IHoverAppearanceOptions, "showHoverHint">;
}
export interface IManagedHover extends IDisposable {
    show(focus?: boolean): void;
    hide(): void;
    update(tooltip: IManagedHoverContent, options?: IManagedHoverOptions): void;
}
