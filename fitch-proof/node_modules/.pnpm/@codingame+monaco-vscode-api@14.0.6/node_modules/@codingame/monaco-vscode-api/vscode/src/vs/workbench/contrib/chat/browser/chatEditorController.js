
import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import './media/chatEditorController.css.js';
import { addStandardDisposableListener, getTotalWidth } from '../../../../base/browser/dom.js';
import { Disposable, DisposableStore, toDisposable, dispose } from '../../../../base/common/lifecycle.js';
import { observableValue } from '../../../../base/common/observableInternal/base.js';
import '../../../../base/common/arrays.js';
import { Event } from '../../../../base/common/event.js';
import { autorun, autorunWithStore } from '../../../../base/common/observableInternal/autorun.js';
import { derived } from '../../../../base/common/observableInternal/derived.js';
import '../../../../base/common/cancellation.js';
import { observableFromEventOpts, observableFromEvent } from '../../../../base/common/observableInternal/utils.js';
import { themeColorFromId } from '../../../../base/common/themables.js';
import { MouseTargetType } from '../../../../editor/browser/editorBrowser.js';
import { RenderOptions, LineSource, renderLines } from '../../../../editor/browser/widget/diffEditor/components/diffEditorViewZones/renderLines.js';
import { diffAddDecoration, diffWholeLineAddDecoration, diffDeleteDecoration } from '../../../../editor/browser/widget/diffEditor/registrations.contribution.js';
import { EditorOption } from '../../../../editor/common/config/editorOptions.js';
import { Range } from '../../../../editor/common/core/range.js';
import { ScrollType } from '../../../../editor/common/editorCommon.js';
import { TrackedRangeStickiness, MinimapPosition, OverviewRulerLane } from '../../../../editor/common/model.js';
import { ModelDecorationOptions } from '../../../../editor/common/model/textModel.js';
import { InlineDecoration, InlineDecorationType } from '../../../../editor/common/viewModel.js';
import { localize } from '../../../../nls.js';
import { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';
import { ChatEditingSessionState, WorkingSetEntryState } from '../common/chatEditingService.js';
import { IChatEditingService } from '../common/chatEditingService.service.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { MenuId } from '../../../../platform/actions/common/actions.js';
import { IEditorService } from '../../../services/editor/common/editorService.service.js';
import { Position } from '../../../../editor/common/core/position.js';
import { Selection } from '../../../../editor/common/core/selection.js';
import { MenuWorkbenchToolBar, HiddenItemStrategy } from '../../../../platform/actions/browser/toolbar.js';
import { observableCodeEditor } from '../../../../editor/browser/observableCodeEditor.js';
import { overviewRulerModifiedForeground, minimapGutterModifiedBackground, overviewRulerAddedForeground, minimapGutterAddedBackground, overviewRulerDeletedForeground, minimapGutterDeletedBackground } from '../../scm/common/quickDiff.js';
import { isDiffEditorForEntry } from './chatEditing/chatEditing.js';
import { isEqual, basename } from '../../../../base/common/resources.js';
import { ChatAgentLocation } from '../common/chatAgents.js';
import { IChatAgentService } from '../common/chatAgents.service.js';
import { EditorsOrder, isDiffEditorInput } from '../../../common/editor.js';
import { ChatEditorOverlayController } from './chatEditorOverlay.js';
import { IChatService } from '../common/chatService.service.js';
import { StableEditorScrollState } from '../../../../editor/browser/stableEditorScroll.js';

var ChatEditorController_1, DiffHunkWidget_1;
const ctxIsGlobalEditingSession = ( new RawContextKey('chat.isGlobalEditingSession', undefined, ( localize(4517, "The current editor is part of the global edit session"))));
const ctxHasEditorModification = ( new RawContextKey('chat.hasEditorModifications', undefined, ( localize(4518, "The current editor contains chat modifications"))));
const ctxHasRequestInProgress = ( new RawContextKey('chat.ctxHasRequestInProgress', false, ( localize(
    4519,
    "The current editor shows a file from an edit session which is still in progress"
))));
const ctxReviewModeEnabled = ( new RawContextKey('chat.ctxReviewModeEnabled', true, ( localize(4520, "Review mode for chat changes is enabled"))));
let ChatEditorController = class ChatEditorController extends Disposable {
    static { ChatEditorController_1 = this; }
    static { this.ID = 'editor.contrib.chatEditorController'; }
    static { this._diffLineDecorationData = ModelDecorationOptions.register({ description: 'diff-line-decoration' }); }
    static get(editor) {
        const controller = editor.getContribution(ChatEditorController_1.ID);
        return controller;
    }
    constructor(_editor, _chatEditingService, _instantiationService, _chatAgentService, _editorService, contextKeyService, chatService) {
        super();
        this._editor = _editor;
        this._chatEditingService = _chatEditingService;
        this._instantiationService = _instantiationService;
        this._chatAgentService = _chatAgentService;
        this._editorService = _editorService;
        this._diffLineDecorations = this._editor.createDecorationsCollection();
        this._diffVisualDecorations = this._editor.createDecorationsCollection();
        this._diffHunksRenderStore = this._register(( new DisposableStore()));
        this._diffHunkWidgets = [];
        this._viewZones = [];
        this._currentEntryIndex = observableValue(this, undefined);
        this.currentEntryIndex = this._currentEntryIndex;
        this._currentChangeIndex = observableValue(this, undefined);
        this.currentChangeIndex = this._currentChangeIndex;
        this._scrollLock = false;
        this._overlayCtrl = ChatEditorOverlayController.get(_editor);
        this._ctxIsGlobalEditsSession = ctxIsGlobalEditingSession.bindTo(contextKeyService);
        this._ctxHasEditorModification = ctxHasEditorModification.bindTo(contextKeyService);
        this._ctxRequestInProgress = ctxHasRequestInProgress.bindTo(contextKeyService);
        this._ctxReviewModelEnabled = ctxReviewModeEnabled.bindTo(contextKeyService);
        const editorObs = observableCodeEditor(this._editor);
        const fontInfoObs = editorObs.getOption(EditorOption.fontInfo);
        const lineHeightObs = editorObs.getOption(EditorOption.lineHeight);
        const modelObs = editorObs.model;
        this._store.add(autorun(r => {
            let isStreamingEdits = false;
            for (const session of _chatEditingService.editingSessionsObs.read(r)) {
                isStreamingEdits ||= session.state.read(r) === ChatEditingSessionState.StreamingEdits;
            }
            this._ctxRequestInProgress.set(isStreamingEdits);
        }));
        const entryForEditor = derived(r => {
            const model = modelObs.read(r);
            if (!model) {
                return;
            }
            for (const session of _chatEditingService.editingSessionsObs.read(r)) {
                const entries = session.entries.read(r);
                const idx = entries.findIndex(e => isEqual(e.modifiedURI, model.uri));
                const chatModel = chatService.getSession(session.chatSessionId);
                if (idx >= 0 && chatModel) {
                    return { session, chatModel, entry: entries[idx], entries, idx };
                }
            }
            return undefined;
        });
        const lastRequest = derived(r => {
            const entry = entryForEditor.read(r);
            if (!entry) {
                return undefined;
            }
            return observableFromEventOpts({ equalsFn: (a, b) => a?.id === b?.id }, entry.chatModel.onDidChange, () => entry.chatModel.getRequests().at(-1)).read(r);
        });
        let scrollState = undefined;
        let didReveal = false;
        this._register(autorun(r => {
            const value = lastRequest.read(r);
            scrollState = value ? StableEditorScrollState.capture(_editor) : undefined;
            didReveal = false;
        }));
        this._register(autorunWithStore((r, store) => {
            const currentEditorEntry = entryForEditor.read(r);
            if (!currentEditorEntry) {
                this._ctxIsGlobalEditsSession.reset();
                this._clear();
                return;
            }
            if (this._editor.getOption(EditorOption.inDiffEditor) && !_instantiationService.invokeFunction(isDiffEditorForEntry, currentEditorEntry.entry, this._editor)) {
                this._clear();
                return;
            }
            const { session, entries, idx, entry } = currentEditorEntry;
            this._ctxIsGlobalEditsSession.set(session.isGlobalEditingSession);
            this._ctxReviewModelEnabled.set(entry.reviewMode.read(r));
            this._currentEntryIndex.set(idx, undefined);
            if (entry.state.read(r) !== WorkingSetEntryState.Modified) {
                this._overlayCtrl.hide();
            }
            else {
                this._overlayCtrl.showEntry(session, entry, entries[(idx + 1) % entries.length], {
                    entryIndex: this._currentEntryIndex,
                    changeIndex: this._currentChangeIndex
                });
            }
            if (entry.isCurrentlyBeingModified.read(r)) {
                if (!this._scrollLock) {
                    const maxLineNumber = entry.maxLineNumber.read(r);
                    this._editor.revealLineNearTop(maxLineNumber, ScrollType.Smooth);
                }
                const domNode = this._editor.getDomNode();
                if (domNode) {
                    store.add(addStandardDisposableListener(domNode, 'wheel', () => {
                        this._scrollLock = true;
                    }));
                }
            }
            else {
                fontInfoObs.read(r);
                lineHeightObs.read(r);
                const diff = entry.diffInfo.read(r);
                this._updateDiffLineDecorations(diff);
                const reviewMode = entry.reviewMode.read(r);
                if (!this._editor.getOption(EditorOption.inDiffEditor)) {
                    this._updateDiffRendering(entry, diff, reviewMode);
                }
                else {
                    this._clearDiffRendering();
                }
                if (lastRequest.read(r)?.response?.isComplete) {
                    if (diff.identical) {
                        scrollState?.restore(_editor);
                        scrollState = undefined;
                    }
                    else if (!didReveal) {
                        this._reveal(true, false, ScrollType.Immediate);
                        didReveal = true;
                    }
                }
            }
        }));
        const shouldBeReadOnly = derived(this, r => {
            const model = modelObs.read(r);
            if (!model) {
                return undefined;
            }
            for (const session of _chatEditingService.editingSessionsObs.read(r)) {
                if (session.readEntry(model.uri, r) && session.state.read(r) === ChatEditingSessionState.StreamingEdits) {
                    return true;
                }
            }
            return false;
        });
        let actualOptions;
        this._register(autorun(r => {
            const value = shouldBeReadOnly.read(r);
            if (value) {
                actualOptions ??= {
                    readOnly: this._editor.getOption(EditorOption.readOnly),
                    renderValidationDecorations: this._editor.getOption(EditorOption.renderValidationDecorations),
                    stickyScroll: this._editor.getOption(EditorOption.stickyScroll)
                };
                this._editor.updateOptions({
                    readOnly: true,
                    renderValidationDecorations: 'off',
                    stickyScroll: { enabled: false }
                });
            }
            else {
                if (actualOptions !== undefined) {
                    this._editor.updateOptions(actualOptions);
                    actualOptions = undefined;
                }
            }
        }));
    }
    dispose() {
        this._clear();
        super.dispose();
    }
    _clear() {
        this._clearDiffRendering();
        this._overlayCtrl.hide();
        this._diffLineDecorations.clear();
        this._currentChangeIndex.set(undefined, undefined);
        this._currentEntryIndex.set(undefined, undefined);
        this._ctxHasEditorModification.reset();
        this._ctxReviewModelEnabled.reset();
    }
    _clearDiffRendering() {
        this._editor.changeViewZones((viewZoneChangeAccessor) => {
            for (const id of this._viewZones) {
                viewZoneChangeAccessor.removeZone(id);
            }
        });
        this._viewZones = [];
        this._diffHunksRenderStore.clear();
        this._diffVisualDecorations.clear();
        this._scrollLock = false;
    }
    _updateDiffRendering(entry, diff, reviewMode) {
        const originalModel = entry.originalModel;
        const chatDiffAddDecoration = ModelDecorationOptions.createDynamic({
            ...diffAddDecoration,
            stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
        });
        const chatDiffWholeLineAddDecoration = ModelDecorationOptions.createDynamic({
            ...diffWholeLineAddDecoration,
            stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        });
        const createOverviewDecoration = (overviewRulerColor, minimapColor) => {
            return ModelDecorationOptions.createDynamic({
                description: 'chat-editing-decoration',
                overviewRuler: { color: themeColorFromId(overviewRulerColor), position: OverviewRulerLane.Left },
                minimap: { color: themeColorFromId(minimapColor), position: MinimapPosition.Gutter },
            });
        };
        const modifiedDecoration = createOverviewDecoration(overviewRulerModifiedForeground, minimapGutterModifiedBackground);
        const addedDecoration = createOverviewDecoration(overviewRulerAddedForeground, minimapGutterAddedBackground);
        const deletedDecoration = createOverviewDecoration(overviewRulerDeletedForeground, minimapGutterDeletedBackground);
        this._diffHunksRenderStore.clear();
        this._diffHunkWidgets.length = 0;
        const diffHunkDecorations = [];
        this._editor.changeViewZones((viewZoneChangeAccessor) => {
            for (const id of this._viewZones) {
                viewZoneChangeAccessor.removeZone(id);
            }
            this._viewZones = [];
            const modifiedVisualDecorations = [];
            const mightContainNonBasicASCII = originalModel.mightContainNonBasicASCII();
            const mightContainRTL = originalModel.mightContainRTL();
            const renderOptions = RenderOptions.fromEditor(this._editor);
            const editorLineCount = this._editor.getModel()?.getLineCount();
            for (const diffEntry of diff.changes) {
                const originalRange = diffEntry.original;
                originalModel.tokenization.forceTokenization(Math.max(1, originalRange.endLineNumberExclusive - 1));
                const source = ( new LineSource(
                    originalRange.mapToLineArray(l => originalModel.tokenization.getLineTokens(l)),
                    [],
                    mightContainNonBasicASCII,
                    mightContainRTL
                ));
                const decorations = [];
                if (reviewMode) {
                    for (const i of diffEntry.innerChanges || []) {
                        decorations.push(( new InlineDecoration(
                            i.originalRange.delta(-(diffEntry.original.startLineNumber - 1)),
                            diffDeleteDecoration.className,
                            InlineDecorationType.Regular
                        )));
                        if (!(i.originalRange.isEmpty() && i.originalRange.startLineNumber === 1 && i.modifiedRange.endLineNumber === editorLineCount) && !i.modifiedRange.isEmpty()) {
                            modifiedVisualDecorations.push({
                                range: i.modifiedRange, options: chatDiffAddDecoration
                            });
                        }
                    }
                }
                const isCreatedContent = decorations.length === 1 && decorations[0].range.isEmpty() && diffEntry.original.startLineNumber === 1;
                if (!diffEntry.modified.isEmpty && !(isCreatedContent && (diffEntry.modified.endLineNumberExclusive - 1) === editorLineCount)) {
                    modifiedVisualDecorations.push({
                        range: diffEntry.modified.toInclusiveRange(),
                        options: chatDiffWholeLineAddDecoration
                    });
                }
                if (diffEntry.original.isEmpty) {
                    modifiedVisualDecorations.push({
                        range: diffEntry.modified.toInclusiveRange(),
                        options: addedDecoration
                    });
                }
                else if (diffEntry.modified.isEmpty) {
                    modifiedVisualDecorations.push({
                        range: ( new Range(
                            diffEntry.modified.startLineNumber - 1,
                            1,
                            diffEntry.modified.startLineNumber,
                            1
                        )),
                        options: deletedDecoration
                    });
                }
                else {
                    modifiedVisualDecorations.push({
                        range: diffEntry.modified.toInclusiveRange(),
                        options: modifiedDecoration
                    });
                }
                if (reviewMode) {
                    const domNode = document.createElement('div');
                    domNode.className = 'chat-editing-original-zone view-lines line-delete monaco-mouse-cursor-text';
                    const result = renderLines(source, renderOptions, decorations, domNode);
                    if (!isCreatedContent) {
                        const viewZoneData = {
                            afterLineNumber: diffEntry.modified.startLineNumber - 1,
                            heightInLines: result.heightInLines,
                            domNode,
                            ordinal: 50000 + 2
                        };
                        this._viewZones.push(viewZoneChangeAccessor.addZone(viewZoneData));
                    }
                    const widget = this._instantiationService.createInstance(DiffHunkWidget, entry, diffEntry, this._editor.getModel().getVersionId(), this._editor, isCreatedContent ? 0 : result.heightInLines);
                    widget.layout(diffEntry.modified.startLineNumber);
                    this._diffHunkWidgets.push(widget);
                    diffHunkDecorations.push({
                        range: diffEntry.modified.toInclusiveRange() ?? ( new Range(
                            diffEntry.modified.startLineNumber,
                            1,
                            diffEntry.modified.startLineNumber,
                            Number.MAX_SAFE_INTEGER
                        )),
                        options: {
                            description: 'diff-hunk-widget',
                            stickiness: TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
                        }
                    });
                }
            }
            this._diffVisualDecorations.set(modifiedVisualDecorations);
        });
        const diffHunkDecoCollection = this._editor.createDecorationsCollection(diffHunkDecorations);
        this._diffHunksRenderStore.add(toDisposable(() => {
            dispose(this._diffHunkWidgets);
            this._diffHunkWidgets.length = 0;
            diffHunkDecoCollection.clear();
        }));
        const positionObs = observableFromEvent(this._editor.onDidChangeCursorPosition, _ => this._editor.getPosition());
        const activeWidgetIdx = derived(r => {
            const position = positionObs.read(r);
            if (!position) {
                return -1;
            }
            const idx = diffHunkDecoCollection.getRanges().findIndex(r => r.containsPosition(position));
            return idx;
        });
        const toggleWidget = (activeWidget) => {
            const positionIdx = activeWidgetIdx.get();
            for (let i = 0; i < this._diffHunkWidgets.length; i++) {
                const widget = this._diffHunkWidgets[i];
                widget.toggle(widget === activeWidget || i === positionIdx);
            }
        };
        this._diffHunksRenderStore.add(autorun(r => {
            const idx = activeWidgetIdx.read(r);
            const widget = this._diffHunkWidgets[idx];
            toggleWidget(widget);
        }));
        this._diffHunksRenderStore.add(this._editor.onMouseMove(e => {
            if (e.target.type === MouseTargetType.OVERLAY_WIDGET) {
                const id = e.target.detail;
                const widget = this._diffHunkWidgets.find(w => w.getId() === id);
                toggleWidget(widget);
            }
            else if (e.target.type === MouseTargetType.CONTENT_VIEW_ZONE) {
                const zone = e.target.detail;
                const idx = this._viewZones.findIndex(id => id === zone.viewZoneId);
                toggleWidget(this._diffHunkWidgets[idx]);
            }
            else if (e.target.position) {
                const { position } = e.target;
                const idx = diffHunkDecoCollection.getRanges().findIndex(r => r.containsPosition(position));
                toggleWidget(this._diffHunkWidgets[idx]);
            }
            else {
                toggleWidget(undefined);
            }
        }));
        this._diffHunksRenderStore.add(Event.any(this._editor.onDidScrollChange, this._editor.onDidLayoutChange)(() => {
            for (let i = 0; i < this._diffHunkWidgets.length; i++) {
                const widget = this._diffHunkWidgets[i];
                const range = diffHunkDecoCollection.getRange(i);
                if (range) {
                    widget.layout(range?.startLineNumber);
                }
                else {
                    widget.dispose();
                }
            }
        }));
    }
    _updateDiffLineDecorations(diff) {
        this._ctxHasEditorModification.set(!diff.identical);
        const modifiedLineDecorations = [];
        for (const diffEntry of diff.changes) {
            modifiedLineDecorations.push({
                range: diffEntry.modified.toInclusiveRange() ?? ( new Range(
                    diffEntry.modified.startLineNumber,
                    1,
                    diffEntry.modified.startLineNumber,
                    Number.MAX_SAFE_INTEGER
                )),
                options: ChatEditorController_1._diffLineDecorationData
            });
        }
        this._diffLineDecorations.set(modifiedLineDecorations);
    }
    unlockScroll() {
        this._scrollLock = false;
    }
    initNavigation() {
        const position = this._editor.getPosition();
        const target = position ? this._diffLineDecorations.getRanges().findIndex(r => r.containsPosition(position)) : -1;
        this._currentChangeIndex.set(target >= 0 ? target : undefined, undefined);
    }
    revealNext(strict = false) {
        return this._reveal(true, strict);
    }
    revealPrevious(strict = false) {
        return this._reveal(false, strict);
    }
    _reveal(next, strict, scrollType = ScrollType.Smooth) {
        const position = this._editor.getPosition();
        if (!position) {
            this._currentChangeIndex.set(undefined, undefined);
            return false;
        }
        const decorations = this._diffLineDecorations
            .getRanges()
            .sort((a, b) => Range.compareRangesUsingStarts(a, b));
        if (decorations.length === 0) {
            this._currentChangeIndex.set(undefined, undefined);
            return false;
        }
        let target = -1;
        for (let i = 0; i < decorations.length; i++) {
            const range = decorations[i];
            if (range.containsPosition(position)) {
                target = i + (next ? 1 : -1);
                break;
            }
            else if (Position.isBefore(position, range.getStartPosition())) {
                target = next ? i : i - 1;
                break;
            }
        }
        if (strict && (target < 0 || target >= decorations.length)) {
            this._currentChangeIndex.set(undefined, undefined);
            return false;
        }
        target = (target + decorations.length) % decorations.length;
        this._currentChangeIndex.set(target, undefined);
        const targetPosition = next ? decorations[target].getStartPosition() : decorations[target].getEndPosition();
        this._editor.setPosition(targetPosition);
        this._editor.revealPositionInCenter(targetPosition, scrollType);
        this._editor.focus();
        return true;
    }
    _findClosestWidget() {
        if (!this._editor.hasModel()) {
            return undefined;
        }
        const lineRelativeTop = this._editor.getTopForLineNumber(this._editor.getPosition().lineNumber) - this._editor.getScrollTop();
        let closestWidget;
        let closestDistance = Number.MAX_VALUE;
        for (const widget of this._diffHunkWidgets) {
            const widgetTop = widget.getPosition()?.preference?.top;
            if (widgetTop !== undefined) {
                const distance = Math.abs(widgetTop - lineRelativeTop);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestWidget = widget;
                }
            }
        }
        return closestWidget;
    }
    rejectNearestChange(closestWidget) {
        closestWidget = closestWidget ?? this._findClosestWidget();
        if (closestWidget instanceof DiffHunkWidget) {
            closestWidget.reject();
            this.revealNext();
        }
    }
    acceptNearestChange(closestWidget) {
        closestWidget = closestWidget ?? this._findClosestWidget();
        if (closestWidget instanceof DiffHunkWidget) {
            closestWidget.accept();
            this.revealNext();
        }
    }
    async toggleDiff(widget) {
        if (!this._editor.hasModel()) {
            return;
        }
        let entry;
        for (const session of this._chatEditingService.editingSessionsObs.get()) {
            entry = session.getEntry(this._editor.getModel().uri);
            if (entry) {
                break;
            }
        }
        if (!entry) {
            return;
        }
        const lineRelativeTop = this._editor.getTopForLineNumber(this._editor.getPosition().lineNumber) - this._editor.getScrollTop();
        let closestDistance = Number.MAX_VALUE;
        if (!(widget instanceof DiffHunkWidget)) {
            for (const candidate of this._diffHunkWidgets) {
                const widgetTop = candidate.getPosition()?.preference?.top;
                if (widgetTop !== undefined) {
                    const distance = Math.abs(widgetTop - lineRelativeTop);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        widget = candidate;
                    }
                }
            }
        }
        let selection = this._editor.getSelection();
        if (widget instanceof DiffHunkWidget) {
            const lineNumber = widget.getStartLineNumber();
            const position = lineNumber ? ( new Position(lineNumber, 1)) : undefined;
            if (position && !selection.containsPosition(position)) {
                selection = Selection.fromPositions(position);
            }
        }
        const isDiffEditor = this._editor.getOption(EditorOption.inDiffEditor);
        if (isDiffEditor) {
            await this._editorService.openEditor({ resource: entry.modifiedURI });
        }
        else {
            const defaultAgentName = this._chatAgentService.getDefaultAgent(ChatAgentLocation.EditingSession)?.fullName;
            const diffEditor = await this._editorService.openEditor({
                original: { resource: entry.originalURI, options: { selection: undefined } },
                modified: { resource: entry.modifiedURI, options: { selection } },
                label: defaultAgentName
                    ? ( localize(
                    4521,
                    '{0} (changes from {1})',
                    basename(entry.modifiedURI),
                    defaultAgentName
                ))
                    : ( localize(4522, '{0} (changes from chat)', basename(entry.modifiedURI)))
            });
            if (diffEditor && diffEditor.input) {
                diffEditor.getControl()?.setSelection(selection);
                const d = autorun(r => {
                    const state = entry.state.read(r);
                    if (state === WorkingSetEntryState.Accepted || state === WorkingSetEntryState.Rejected) {
                        d.dispose();
                        const editorIdents = [];
                        for (const candidate of this._editorService.getEditors(EditorsOrder.MOST_RECENTLY_ACTIVE)) {
                            if (isDiffEditorInput(candidate.editor)
                                && isEqual(candidate.editor.original.resource, entry.originalURI)
                                && isEqual(candidate.editor.modified.resource, entry.modifiedURI)) {
                                editorIdents.push(candidate);
                            }
                        }
                        this._editorService.closeEditors(editorIdents);
                    }
                });
            }
        }
    }
};
ChatEditorController = ChatEditorController_1 = ( __decorate([
    ( __param(1, IChatEditingService)),
    ( __param(2, IInstantiationService)),
    ( __param(3, IChatAgentService)),
    ( __param(4, IEditorService)),
    ( __param(5, IContextKeyService)),
    ( __param(6, IChatService))
], ChatEditorController));
let DiffHunkWidget = class DiffHunkWidget {
    static { DiffHunkWidget_1 = this; }
    static { this._idPool = 0; }
    constructor(entry, _change, _versionId, _editor, _lineDelta, instaService) {
        this.entry = entry;
        this._change = _change;
        this._versionId = _versionId;
        this._editor = _editor;
        this._lineDelta = _lineDelta;
        this._id = `diff-change-widget-${DiffHunkWidget_1._idPool++}`;
        this._store = ( new DisposableStore());
        this._domNode = document.createElement('div');
        this._domNode.className = 'chat-diff-change-content-widget';
        const toolbar = instaService.createInstance(MenuWorkbenchToolBar, this._domNode, MenuId.ChatEditingEditorHunk, {
            telemetrySource: 'chatEditingEditorHunk',
            hiddenItemStrategy: HiddenItemStrategy.NoHide,
            toolbarOptions: { primaryGroup: () => true, },
            menuOptions: {
                renderShortTitle: true,
                arg: this,
            },
        });
        this._store.add(toolbar);
        this._store.add(toolbar.actionRunner.onWillRun(_ => _editor.focus()));
        this._editor.addOverlayWidget(this);
    }
    dispose() {
        this._store.dispose();
        this._editor.removeOverlayWidget(this);
    }
    getId() {
        return this._id;
    }
    layout(startLineNumber) {
        const lineHeight = this._editor.getOption(EditorOption.lineHeight);
        const { contentLeft, contentWidth, verticalScrollbarWidth } = this._editor.getLayoutInfo();
        const scrollTop = this._editor.getScrollTop();
        this._position = {
            stackOridinal: 1,
            preference: {
                top: this._editor.getTopForLineNumber(startLineNumber) - scrollTop - (lineHeight * this._lineDelta),
                left: contentLeft + contentWidth - (2 * verticalScrollbarWidth + getTotalWidth(this._domNode))
            }
        };
        this._editor.layoutOverlayWidget(this);
        this._lastStartLineNumber = startLineNumber;
    }
    toggle(show) {
        this._domNode.classList.toggle('hover', show);
        if (this._lastStartLineNumber) {
            this.layout(this._lastStartLineNumber);
        }
    }
    getDomNode() {
        return this._domNode;
    }
    getPosition() {
        return this._position ?? null;
    }
    getStartLineNumber() {
        return this._lastStartLineNumber;
    }
    reject() {
        if (this._versionId === this._editor.getModel()?.getVersionId()) {
            this.entry.rejectHunk(this._change);
        }
    }
    accept() {
        if (this._versionId === this._editor.getModel()?.getVersionId()) {
            this.entry.acceptHunk(this._change);
        }
    }
};
DiffHunkWidget = DiffHunkWidget_1 = ( __decorate([
    ( __param(5, IInstantiationService))
], DiffHunkWidget));

export { ChatEditorController, ctxHasEditorModification, ctxHasRequestInProgress, ctxIsGlobalEditingSession, ctxReviewModeEnabled };
