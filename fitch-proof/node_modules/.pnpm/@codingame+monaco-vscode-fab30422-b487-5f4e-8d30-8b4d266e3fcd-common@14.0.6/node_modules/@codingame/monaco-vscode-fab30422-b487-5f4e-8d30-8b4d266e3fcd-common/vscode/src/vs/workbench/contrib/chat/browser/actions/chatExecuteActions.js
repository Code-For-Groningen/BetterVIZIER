
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { KeyCode, KeyMod } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { localize2, localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { Action2, MenuId, MenuRegistry, registerAction2 } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { IViewsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/views/common/viewsService.service';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { IChatAgentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents.service';
import { ChatContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatContextKeys';
import { WorkingSetEntryState, applyingChatEditsContextKey } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService.service';
import { extractAgentAndCommand, chatAgentLeader } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatParserTypes';
import { IChatService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatService.service';
import { EditsViewId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat';
import { IChatWidgetService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat.service';
import { discardAllEditsWithConfirmation } from '../chatEditing/chatEditingActions.js';
import { CHAT_CATEGORY } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/actions/chatActions';
import { ChatDoneActionId } from './chatClearActions.js';

class SubmitAction extends Action2 {
    run(accessor, ...args) {
        const context = args[0];
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        widget?.acceptInput(context?.inputValue);
    }
}
class ChatSubmitAction extends SubmitAction {
    static { this.ID = 'workbench.action.chat.submit'; }
    constructor() {
        const precondition = ( ContextKeyExpr.and((
        ContextKeyExpr.or(ChatContextKeys.inputHasText, ChatContextKeys.instructionsAttached)), ( ChatContextKeys.requestInProgress.negate()), ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.EditingSession))));
        super({
            id: ChatSubmitAction.ID,
            title: ( localize2(4307, "Send and Dispatch")),
            f1: false,
            category: CHAT_CATEGORY,
            icon: Codicon.send,
            precondition,
            keybinding: {
                when: ChatContextKeys.inChatInput,
                primary: KeyCode.Enter,
                weight: KeybindingWeight.EditorContrib
            },
            menu: [
                {
                    id: MenuId.ChatExecuteSecondary,
                    group: 'group_1',
                    order: 1
                },
                {
                    id: MenuId.ChatExecute,
                    order: 4,
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate()))), ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.EditingSession)))),
                    group: 'navigation',
                },
            ]
        });
    }
}
const ToggleAgentModeActionId = 'workbench.action.chat.toggleAgentMode';
class ToggleAgentModeAction extends Action2 {
    static { this.ID = ToggleAgentModeActionId; }
    constructor() {
        super({
            id: ToggleAgentModeAction.ID,
            title: ( localize2(4308, "Toggle Agent Mode (Experimental)")),
            f1: true,
            category: CHAT_CATEGORY,
            precondition: ( ContextKeyExpr.and(ChatContextKeys.Editing.hasToolsAgent, ( ChatContextKeys.requestInProgress.negate()))),
            toggled: {
                condition: ChatContextKeys.Editing.agentMode,
                tooltip: ( localize(4309, "Agent Mode Enabled (Experimental)")),
            },
            tooltip: ( localize(4310, "Agent Mode Disabled")),
            keybinding: {
                when: ( ContextKeyExpr.and(ChatContextKeys.inChatInput, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)))),
                primary: KeyMod.CtrlCmd | KeyCode.Period,
                weight: KeybindingWeight.EditorContrib
            },
            menu: [
                {
                    id: MenuId.ChatExecute,
                    order: 1,
                    when: ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ChatContextKeys.Editing.hasToolsAgent)),
                    group: 'navigation',
                },
            ]
        });
    }
    async run(accessor, ...args) {
        const agentService = accessor.get(IChatAgentService);
        const chatEditingService = accessor.get(IChatEditingService);
        const chatService = accessor.get(IChatService);
        const commandService = accessor.get(ICommandService);
        const dialogService = accessor.get(IDialogService);
        const currentEditingSession = chatEditingService.currentEditingSession;
        if (!currentEditingSession) {
            return;
        }
        const entries = currentEditingSession.entries.get();
        if (entries.length > 0 && ( entries.some(entry => entry.state.get() === WorkingSetEntryState.Modified))) {
            if (!(await discardAllEditsWithConfirmation(accessor))) {
                return;
            }
        }
        else {
            const chatSession = chatService.getSession(currentEditingSession.chatSessionId);
            if (chatSession?.getRequests().length) {
                const confirmation = await dialogService.confirm({
                    title: ( localize(4311, "Start new session?")),
                    message: ( localize(
                        4312,
                        "Toggling agent mode will start a new session. Would you like to continue?"
                    )),
                    primaryButton: ( localize(4313, "Yes")),
                    type: 'info'
                });
                if (!confirmation.confirmed) {
                    return;
                }
            }
        }
        const arg = args[0];
        agentService.toggleToolsAgentMode(typeof arg?.agentMode === 'boolean' ? arg.agentMode : undefined);
        await commandService.executeCommand(ChatDoneActionId);
    }
}
const ToggleRequestPausedActionId = 'workbench.action.chat.toggleRequestPaused';
class ToggleRequestPausedAction extends Action2 {
    static { this.ID = ToggleRequestPausedActionId; }
    constructor() {
        super({
            id: ToggleRequestPausedAction.ID,
            title: ( localize2(4314, "Toggle Request Paused")),
            category: CHAT_CATEGORY,
            icon: Codicon.debugPause,
            toggled: {
                condition: ChatContextKeys.isRequestPaused,
                icon: Codicon.play,
                tooltip: ( localize(4315, "Resume Request")),
            },
            tooltip: ( localize(4316, "Pause Request")),
            menu: [
                {
                    id: MenuId.ChatExecute,
                    order: 3.5,
                    when: ( ContextKeyExpr.and(
                        ChatContextKeys.canRequestBePaused,
                        ChatContextKeys.Editing.agentMode,
                        ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))
                    )),
                    group: 'navigation',
                },
            ]
        });
    }
    run(accessor, ...args) {
        const context = args[0];
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        widget?.togglePaused();
    }
}
class ChatEditingSessionSubmitAction extends SubmitAction {
    static { this.ID = 'workbench.action.edits.submit'; }
    constructor() {
        const precondition = ( ContextKeyExpr.and((
        ContextKeyExpr.or(ChatContextKeys.inputHasText, ChatContextKeys.instructionsAttached)), ( applyingChatEditsContextKey.toNegated()), ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))));
        super({
            id: ChatEditingSessionSubmitAction.ID,
            title: ( localize2(4317, "Send")),
            f1: false,
            category: CHAT_CATEGORY,
            icon: Codicon.send,
            precondition,
            keybinding: {
                when: ChatContextKeys.inChatInput,
                primary: KeyCode.Enter,
                weight: KeybindingWeight.EditorContrib
            },
            menu: [
                {
                    id: MenuId.ChatExecuteSecondary,
                    group: 'group_1',
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate()))), ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ( applyingChatEditsContextKey.toNegated()))),
                    order: 1
                },
                {
                    id: MenuId.ChatExecute,
                    order: 4,
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate()))), ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ( applyingChatEditsContextKey.toNegated()))),
                    group: 'navigation',
                },
            ]
        });
    }
}
class SubmitWithoutDispatchingAction extends Action2 {
    static { this.ID = 'workbench.action.chat.submitWithoutDispatching'; }
    constructor() {
        const precondition = ( ContextKeyExpr.and((
        ContextKeyExpr.or(ChatContextKeys.inputHasText, ChatContextKeys.instructionsAttached)), ( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate()))), ( ContextKeyExpr.and(( ContextKeyExpr.or(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.Panel)), ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.Editor))))))));
        super({
            id: SubmitWithoutDispatchingAction.ID,
            title: ( localize2(4318, "Send")),
            f1: false,
            category: CHAT_CATEGORY,
            precondition,
            keybinding: {
                when: ChatContextKeys.inChatInput,
                primary: KeyMod.Alt | KeyMod.Shift | KeyCode.Enter,
                weight: KeybindingWeight.EditorContrib
            },
            menu: [
                {
                    id: MenuId.ChatExecuteSecondary,
                    group: 'group_1',
                    order: 2
                }
            ]
        });
    }
    run(accessor, ...args) {
        const context = args[0];
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        widget?.acceptInput(context?.inputValue, { noCommandDetection: true });
    }
}
const ChatModelPickerActionId = 'workbench.action.chat.pickModel';
MenuRegistry.appendMenuItem(MenuId.ChatExecute, {
    command: {
        id: ChatModelPickerActionId,
        title: ( localize2(4319, "Pick Model")),
    },
    order: 3,
    group: 'navigation',
    when: ( ContextKeyExpr.and(ChatContextKeys.languageModelsAreUserSelectable, ( ContextKeyExpr.or(( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.Panel)), ( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.EditingSession)), ( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.Editor)), ( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.Notebook)), ( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.Terminal)))))),
});
class ChatSubmitSecondaryAgentAction extends Action2 {
    static { this.ID = 'workbench.action.chat.submitSecondaryAgent'; }
    constructor() {
        const precondition = ( ContextKeyExpr.and((
        ContextKeyExpr.or(ChatContextKeys.inputHasText, ChatContextKeys.instructionsAttached)), ( ChatContextKeys.inputHasAgent.negate()), ( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate())))));
        super({
            id: ChatSubmitSecondaryAgentAction.ID,
            title: ( localize2(4320, "Submit to Secondary Agent")),
            precondition,
            menu: {
                id: MenuId.ChatExecuteSecondary,
                group: 'group_1',
                order: 3,
                when: ( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.Panel))
            },
            keybinding: {
                when: ChatContextKeys.inChatInput,
                primary: KeyMod.CtrlCmd | KeyCode.Enter,
                weight: KeybindingWeight.EditorContrib
            },
        });
    }
    run(accessor, ...args) {
        const context = args[0];
        const agentService = accessor.get(IChatAgentService);
        const secondaryAgent = agentService.getSecondaryAgent();
        if (!secondaryAgent) {
            return;
        }
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        if (!widget) {
            return;
        }
        if (extractAgentAndCommand(widget.parsedInput).agentPart) {
            widget.acceptInput();
        }
        else {
            widget.lastSelectedAgent = secondaryAgent;
            widget.acceptInputWithPrefix(`${chatAgentLeader}${secondaryAgent.name}`);
        }
    }
}
class SendToChatEditingAction extends Action2 {
    constructor() {
        const precondition = ( ContextKeyExpr.and((
        ContextKeyExpr.or(ChatContextKeys.inputHasText, ChatContextKeys.instructionsAttached)), ( ChatContextKeys.inputHasAgent.negate()), ( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate())))));
        super({
            id: 'workbench.action.chat.sendToChatEditing',
            title: ( localize2(4321, "Send to Copilot Edits")),
            precondition,
            category: CHAT_CATEGORY,
            f1: false,
            menu: {
                id: MenuId.ChatExecuteSecondary,
                group: 'group_1',
                order: 4,
                when: ( ContextKeyExpr.and(
                    ChatContextKeys.enabled,
                    ChatContextKeys.editingParticipantRegistered,
                    ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.EditingSession)),
                    ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.Editor))
                ))
            },
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.CtrlCmd | KeyMod.Alt | KeyCode.Enter,
                when: ( ContextKeyExpr.and(
                    ChatContextKeys.enabled,
                    ChatContextKeys.editingParticipantRegistered,
                    ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.EditingSession)),
                    ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.Editor))
                ))
            }
        });
    }
    async run(accessor, ...args) {
        if (!accessor.get(IChatAgentService).getDefaultAgent(ChatAgentLocation.EditingSession)) {
            return;
        }
        const context = args[0];
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        if (!widget || widget.viewModel?.model.initialLocation === ChatAgentLocation.EditingSession) {
            return;
        }
        const viewsService = accessor.get(IViewsService);
        const dialogService = accessor.get(IDialogService);
        const chatEditingService = accessor.get(IChatEditingService);
        const currentEditingSession = chatEditingService.currentEditingSessionObs.get();
        const currentEditCount = currentEditingSession?.entries.get().length;
        if (currentEditCount) {
            const result = await dialogService.confirm({
                title: ( localize(4322, "Start new editing session?")),
                message: currentEditCount === 1
                    ? ( localize(
                    4323,
                    "Starting a new editing session will end your current editing session containing {0} file. Do you wish to proceed?",
                    currentEditCount
                ))
                    : ( localize(
                    4324,
                    "Starting a new editing session will end your current editing session containing {0} files. Do you wish to proceed?",
                    currentEditCount
                )),
                type: 'info',
                primaryButton: ( localize(4325, "Yes"))
            });
            if (!result.confirmed) {
                return;
            }
            await currentEditingSession?.stop(true);
        }
        const { widget: editingWidget } = await viewsService.openView(EditsViewId);
        for (const attachment of widget.attachmentModel.attachments) {
            if (attachment.isFile && URI.isUri(attachment.value)) {
                chatEditingService.currentEditingSessionObs.get()?.addFileToWorkingSet(attachment.value);
            }
            else {
                editingWidget.attachmentModel.addContext(attachment);
            }
        }
        editingWidget.setInput(widget.getInput());
        widget.setInput('');
        widget.attachmentModel.clear();
        editingWidget.acceptInput();
        editingWidget.focusInput();
    }
}
class SendToNewChatAction extends Action2 {
    constructor() {
        const precondition = ( ContextKeyExpr.and((
        ContextKeyExpr.or(ChatContextKeys.inputHasText, ChatContextKeys.instructionsAttached)), ( ContextKeyExpr.or(ChatContextKeys.isRequestPaused, ( ChatContextKeys.requestInProgress.negate())))));
        super({
            id: 'workbench.action.chat.sendToNewChat',
            title: ( localize2(4326, "Send to New Chat")),
            precondition,
            category: CHAT_CATEGORY,
            f1: false,
            menu: {
                id: MenuId.ChatExecuteSecondary,
                group: 'group_2',
                when: ( ContextKeyExpr.equals(ChatContextKeys.location.key, ChatAgentLocation.Panel))
            },
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.Enter,
                when: ChatContextKeys.inChatInput,
            }
        });
    }
    async run(accessor, ...args) {
        const context = args[0];
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        if (!widget) {
            return;
        }
        widget.clear();
        widget.acceptInput(context?.inputValue);
    }
}
class CancelAction extends Action2 {
    static { this.ID = 'workbench.action.chat.cancel'; }
    constructor() {
        super({
            id: CancelAction.ID,
            title: ( localize2(4327, "Cancel")),
            f1: false,
            category: CHAT_CATEGORY,
            icon: Codicon.stopCircle,
            menu: {
                id: MenuId.ChatExecute,
                when: ( ContextKeyExpr.or(( ContextKeyExpr.and(( ChatContextKeys.isRequestPaused.negate()), ChatContextKeys.requestInProgress)), ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), applyingChatEditsContextKey)))),
                order: 4,
                group: 'navigation',
            },
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.CtrlCmd | KeyCode.Escape,
                win: { primary: KeyMod.Alt | KeyCode.Backspace },
            }
        });
    }
    run(accessor, ...args) {
        const context = args[0];
        const widgetService = accessor.get(IChatWidgetService);
        const widget = context?.widget ?? widgetService.lastFocusedWidget;
        if (!widget) {
            return;
        }
        const chatService = accessor.get(IChatService);
        if (widget.viewModel) {
            chatService.cancelCurrentRequestForSession(widget.viewModel.sessionId);
        }
        const chatEditingService = accessor.get(IChatEditingService);
        const currentEditingSession = chatEditingService.currentEditingSession;
        if (currentEditingSession && currentEditingSession?.chatSessionId === widget.viewModel?.sessionId) {
            chatEditingService.currentAutoApplyOperation?.cancel();
        }
    }
}
function registerChatExecuteActions() {
    registerAction2(ChatSubmitAction);
    registerAction2(ChatEditingSessionSubmitAction);
    registerAction2(SubmitWithoutDispatchingAction);
    registerAction2(CancelAction);
    registerAction2(SendToNewChatAction);
    registerAction2(ChatSubmitSecondaryAgentAction);
    registerAction2(SendToChatEditingAction);
    registerAction2(ToggleAgentModeAction);
    registerAction2(ToggleRequestPausedAction);
}

export { CancelAction, ChatEditingSessionSubmitAction, ChatModelPickerActionId, ChatSubmitAction, ChatSubmitSecondaryAgentAction, ToggleAgentModeAction, ToggleAgentModeActionId, ToggleRequestPausedAction, ToggleRequestPausedActionId, registerChatExecuteActions };
