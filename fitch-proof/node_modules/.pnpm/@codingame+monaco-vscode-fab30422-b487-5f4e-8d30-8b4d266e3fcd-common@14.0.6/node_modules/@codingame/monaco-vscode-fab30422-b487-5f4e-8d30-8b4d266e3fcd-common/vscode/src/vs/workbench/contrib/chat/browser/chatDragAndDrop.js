
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { DataTransfers } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dnd';
import { DragAndDropObserver, $ } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { renderLabelWithIcons } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/iconLabel/iconLabels';
import { coalesce } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { Mimes } from '@codingame/monaco-vscode-api/vscode/vs/base/common/mime';
import { joinPath, basename } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { SymbolKinds } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { containsDragType, CodeDataTransfers, extractSymbolDropData, extractEditorsDropData } from '@codingame/monaco-vscode-api/vscode/vs/platform/dnd/browser/dnd';
import { FileType } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { Themable } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/themeService';
import { IThemeService } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/themeService.service';
import { isUntitledResourceEditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { isProposedApiEnabled } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { UntitledTextEditorInput } from '@codingame/monaco-vscode-5945a5e2-a66c-5a82-bd2c-1965724b29eb-common/vscode/vs/workbench/services/untitled/common/untitledTextEditorInput';
import { resizeImage } from './imageUtils.js';

var ChatDragAndDropType;
(function (ChatDragAndDropType) {
    ChatDragAndDropType[ChatDragAndDropType["FILE_INTERNAL"] = 0] = "FILE_INTERNAL";
    ChatDragAndDropType[ChatDragAndDropType["FILE_EXTERNAL"] = 1] = "FILE_EXTERNAL";
    ChatDragAndDropType[ChatDragAndDropType["FOLDER"] = 2] = "FOLDER";
    ChatDragAndDropType[ChatDragAndDropType["IMAGE"] = 3] = "IMAGE";
    ChatDragAndDropType[ChatDragAndDropType["SYMBOL"] = 4] = "SYMBOL";
})(ChatDragAndDropType || (ChatDragAndDropType = {}));
let ChatDragAndDrop = class ChatDragAndDrop extends Themable {
    constructor(attachmentModel, styles, themeService, extensionService, fileService, editorService) {
        super(themeService);
        this.attachmentModel = attachmentModel;
        this.styles = styles;
        this.extensionService = extensionService;
        this.fileService = fileService;
        this.editorService = editorService;
        this.overlays = ( new Map());
        this.overlayTextBackground = '';
        this.currentActiveTarget = undefined;
        this.updateStyles();
    }
    addOverlay(target, overlayContainer) {
        this.removeOverlay(target);
        const { overlay, disposable } = this.createOverlay(target, overlayContainer);
        this.overlays.set(target, { overlay, disposable });
    }
    removeOverlay(target) {
        if (this.currentActiveTarget === target) {
            this.currentActiveTarget = undefined;
        }
        const existingOverlay = this.overlays.get(target);
        if (existingOverlay) {
            existingOverlay.overlay.remove();
            existingOverlay.disposable.dispose();
            this.overlays.delete(target);
        }
    }
    createOverlay(target, overlayContainer) {
        const overlay = document.createElement('div');
        overlay.classList.add('chat-dnd-overlay');
        this.updateOverlayStyles(overlay);
        overlayContainer.appendChild(overlay);
        const disposable = ( new DragAndDropObserver(target, {
            onDragOver: (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (target === this.currentActiveTarget) {
                    return;
                }
                if (this.currentActiveTarget) {
                    this.setOverlay(this.currentActiveTarget, undefined);
                }
                this.currentActiveTarget = target;
                this.onDragEnter(e, target);
            },
            onDragLeave: (e) => {
                if (target === this.currentActiveTarget) {
                    this.currentActiveTarget = undefined;
                }
                this.onDragLeave(e, target);
            },
            onDrop: (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (target !== this.currentActiveTarget) {
                    return;
                }
                this.currentActiveTarget = undefined;
                this.onDrop(e, target);
            },
        }));
        return { overlay, disposable };
    }
    onDragEnter(e, target) {
        const estimatedDropType = this.guessDropType(e);
        this.updateDropFeedback(e, target, estimatedDropType);
    }
    onDragLeave(e, target) {
        this.updateDropFeedback(e, target, undefined);
    }
    onDrop(e, target) {
        this.updateDropFeedback(e, target, undefined);
        this.drop(e);
    }
    async drop(e) {
        const contexts = await this.getAttachContext(e);
        if (contexts.length === 0) {
            return;
        }
        this.handleDrop(contexts);
    }
    handleDrop(contexts) {
        this.attachmentModel.addContext(...contexts);
    }
    updateDropFeedback(e, target, dropType) {
        const showOverlay = dropType !== undefined;
        if (e.dataTransfer) {
            e.dataTransfer.dropEffect = showOverlay ? 'copy' : 'none';
        }
        this.setOverlay(target, dropType);
    }
    guessDropType(e) {
        if (this.isImageDnd(e)) {
            return ( this.extensionService.extensions.some(ext => isProposedApiEnabled(ext, 'chatReferenceBinaryData'))) ? ChatDragAndDropType.IMAGE : undefined;
        }
        else if (containsDragType(e, CodeDataTransfers.SYMBOLS)) {
            return ChatDragAndDropType.SYMBOL;
        }
        else if (containsDragType(e, DataTransfers.FILES)) {
            return ChatDragAndDropType.FILE_EXTERNAL;
        }
        else if (containsDragType(e, DataTransfers.INTERNAL_URI_LIST)) {
            return ChatDragAndDropType.FILE_INTERNAL;
        }
        else if (containsDragType(e, Mimes.uriList, CodeDataTransfers.FILES)) {
            return ChatDragAndDropType.FOLDER;
        }
        return undefined;
    }
    isDragEventSupported(e) {
        const dropType = this.guessDropType(e);
        return dropType !== undefined;
    }
    getDropTypeName(type) {
        switch (type) {
            case ChatDragAndDropType.FILE_INTERNAL: return localize(4458, 'File');
            case ChatDragAndDropType.FILE_EXTERNAL: return localize(4458, 'File');
            case ChatDragAndDropType.FOLDER: return localize(4459, 'Folder');
            case ChatDragAndDropType.IMAGE: return localize(4460, 'Image');
            case ChatDragAndDropType.SYMBOL: return localize(4461, 'Symbol');
        }
    }
    isImageDnd(e) {
        if (containsDragType(e, 'image')) {
            return true;
        }
        if (containsDragType(e, DataTransfers.FILES)) {
            const files = e.dataTransfer?.files;
            if (files && files.length > 0) {
                const file = files[0];
                return file.type.startsWith('image/');
            }
            const items = e.dataTransfer?.items;
            if (items && items.length > 0) {
                const item = items[0];
                return item.type.startsWith('image/');
            }
        }
        return false;
    }
    async getAttachContext(e) {
        if (!this.isDragEventSupported(e)) {
            return [];
        }
        if (containsDragType(e, CodeDataTransfers.SYMBOLS)) {
            const data = extractSymbolDropData(e);
            return this.resolveSymbolsAttachContext(data);
        }
        const data = extractEditorsDropData(e);
        return coalesce(await Promise.all(( data.map(editorInput => {
            return this.resolveAttachContext(editorInput);
        }))));
    }
    async resolveAttachContext(editorInput) {
        const imageContext = await getImageAttachContext(editorInput, this.fileService);
        if (imageContext) {
            return ( this.extensionService.extensions.some(ext => isProposedApiEnabled(ext, 'chatReferenceBinaryData'))) ? imageContext : undefined;
        }
        return await this.getEditorAttachContext(editorInput);
    }
    async getEditorAttachContext(editor) {
        if (isUntitledResourceEditorInput(editor)) {
            return await this.resolveUntitledAttachContext(editor);
        }
        if (!editor.resource) {
            return undefined;
        }
        let stat;
        try {
            stat = await this.fileService.stat(editor.resource);
        }
        catch {
            return undefined;
        }
        if (!stat.isDirectory && !stat.isFile) {
            return undefined;
        }
        return getResourceAttachContext(editor.resource, stat.isDirectory);
    }
    async resolveUntitledAttachContext(editor) {
        if (editor.resource) {
            return getResourceAttachContext(editor.resource, false);
        }
        const openUntitledEditors = this.editorService.editors.filter(editor => editor instanceof UntitledTextEditorInput);
        for (const canidate of openUntitledEditors) {
            const model = await canidate.resolve();
            const contents = model.textEditorModel?.getValue();
            if (contents === editor.contents) {
                return getResourceAttachContext(canidate.resource, false);
            }
        }
        return undefined;
    }
    resolveSymbolsAttachContext(symbols) {
        return ( symbols.map(symbol => {
            const resource = URI.file(symbol.fsPath);
            return {
                kind: 'symbol',
                id: symbolId(resource, symbol.range),
                value: { uri: resource, range: symbol.range },
                symbolKind: symbol.kind,
                fullName: `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbol.name}`,
                name: symbol.name,
                isDynamic: true
            };
        }));
    }
    setOverlay(target, type) {
        this.overlayText?.remove();
        this.overlayText = undefined;
        const { overlay } = this.overlays.get(target);
        if (type !== undefined) {
            const iconAndtextElements = renderLabelWithIcons(`$(${Codicon.attach.id}) ${this.getOverlayText(type)}`);
            const htmlElements = ( iconAndtextElements.map(element => {
                if (typeof element === 'string') {
                    return $('span.overlay-text', undefined, element);
                }
                return element;
            }));
            this.overlayText = $('span.attach-context-overlay-text', undefined, ...htmlElements);
            this.overlayText.style.backgroundColor = this.overlayTextBackground;
            overlay.appendChild(this.overlayText);
        }
        overlay.classList.toggle('visible', type !== undefined);
    }
    getOverlayText(type) {
        const typeName = this.getDropTypeName(type);
        return localize(4462, 'Attach {0} as Context', typeName);
    }
    updateOverlayStyles(overlay) {
        overlay.style.backgroundColor = this.getColor(this.styles.overlayBackground) || '';
        overlay.style.color = this.getColor(this.styles.listForeground) || '';
    }
    updateStyles() {
        this.overlays.forEach(overlay => this.updateOverlayStyles(overlay.overlay));
        this.overlayTextBackground = this.getColor(this.styles.listBackground) || '';
    }
};
ChatDragAndDrop = ( __decorate([
    ( __param(2, IThemeService)),
    ( __param(3, IExtensionService)),
    ( __param(4, IFileService)),
    ( __param(5, IEditorService))
], ChatDragAndDrop));
let EditsDragAndDrop = class EditsDragAndDrop extends ChatDragAndDrop {
    constructor(attachmentModel, styles, themeService, extensionService, fileService, editorService) {
        super(attachmentModel, styles, themeService, extensionService, fileService, editorService);
    }
    handleDrop(context) {
        this.handleDropAsync(context);
    }
    async handleDropAsync(context) {
        const nonDirectoryContext = context.filter(context => !context.isDirectory);
        const directories = ( context
            .filter(context => context.isDirectory)
            .map(context => context.value))
            .filter(value => !!value && URI.isUri(value));
        for (const directory of directories) {
            const fileSystemProvider = this.fileService.getProvider(directory.scheme);
            if (!fileSystemProvider) {
                continue;
            }
            const resolvedFiles = await resolveFilesInDirectory(directory, fileSystemProvider, true);
            const resolvedFileContext = ( resolvedFiles.map(file => getResourceAttachContext(file, false))).filter(context => !!context);
            nonDirectoryContext.push(...resolvedFileContext);
        }
        super.handleDrop(nonDirectoryContext);
    }
    getOverlayText(type) {
        const typeName = this.getDropTypeName(type);
        switch (type) {
            case ChatDragAndDropType.FILE_INTERNAL:
            case ChatDragAndDropType.FILE_EXTERNAL:
                return localize(4463, 'Add {0} to Working Set', typeName);
            case ChatDragAndDropType.FOLDER:
                return localize(4463, 'Add {0} to Working Set', localize(4464, 'Files'));
            default:
                return super.getOverlayText(type);
        }
    }
};
EditsDragAndDrop = ( __decorate([
    ( __param(2, IThemeService)),
    ( __param(3, IExtensionService)),
    ( __param(4, IFileService)),
    ( __param(5, IEditorService))
], EditsDragAndDrop));
async function resolveFilesInDirectory(resource, fileSystemProvider, shouldRecurse) {
    const entries = await fileSystemProvider.readdir(resource);
    const files = [];
    const folders = [];
    for (const [name, type] of entries) {
        const entryResource = joinPath(resource, name);
        if (type === FileType.File) {
            files.push(entryResource);
        }
        else if (type === FileType.Directory && shouldRecurse) {
            folders.push(entryResource);
        }
    }
    const subFiles = await Promise.all(( folders.map(
        folder => resolveFilesInDirectory(folder, fileSystemProvider, shouldRecurse)
    )));
    return [...files, ...subFiles.flat()];
}
function getResourceAttachContext(resource, isDirectory) {
    return {
        value: resource,
        id: ( resource.toString()),
        name: basename(resource),
        isFile: !isDirectory,
        isDirectory,
        isDynamic: true
    };
}
async function getImageAttachContext(editor, fileService) {
    if (!editor.resource) {
        return undefined;
    }
    if (/\.(png|jpg|jpeg|gif|webp)$/i.test(editor.resource.path)) {
        const fileName = basename(editor.resource);
        const readFile = await fileService.readFile(editor.resource);
        const resizedImage = await resizeImage(readFile.value.buffer);
        return {
            id: ( editor.resource.toString()),
            name: fileName,
            fullName: editor.resource.path,
            value: resizedImage,
            icon: Codicon.fileMedia,
            isDynamic: true,
            isImage: true,
            isFile: false,
            references: [{ reference: editor.resource, kind: 'reference' }]
        };
    }
    return undefined;
}
function symbolId(resource, range) {
    let rangePart = '';
    if (range) {
        rangePart = `:${range.startLineNumber}`;
        if (range.startLineNumber !== range.endLineNumber) {
            rangePart += `-${range.endLineNumber}`;
        }
    }
    return resource.fsPath + rangePart;
}

export { ChatDragAndDrop, EditsDragAndDrop };
