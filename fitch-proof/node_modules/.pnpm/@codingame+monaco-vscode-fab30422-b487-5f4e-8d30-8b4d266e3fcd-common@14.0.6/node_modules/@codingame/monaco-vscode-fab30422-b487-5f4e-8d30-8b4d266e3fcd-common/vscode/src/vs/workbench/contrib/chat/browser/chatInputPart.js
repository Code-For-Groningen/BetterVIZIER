
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { $ as $$1, h, append, addStandardDisposableListener, EventType, clearNode, setVisibility, addDisposableListener, EventHelper, isKeyboardEvent, Dimension, getTotalWidth, reset } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { DEFAULT_FONT_FAMILY } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/fonts';
import { StandardKeyboardEvent } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/keyboardEvent';
import { status } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/aria/aria';
import { Button } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/button/button';
import { getBaseLayerHoverDelegate } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/hover/hoverDelegate2';
import { createInstantHoverDelegate, getDefaultHoverDelegate } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/hover/hoverDelegateFactory';
import { HoverPosition } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/hover/hoverWidget';
import { renderLabelWithIcons } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/iconLabel/iconLabels';
import { Separator, toAction } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { coalesce } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { Promises } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { Emitter, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { HistoryNavigator2 } from '@codingame/monaco-vscode-api/vscode/vs/base/common/history';
import { KeyCode } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { Disposable, DisposableStore, MutableDisposable, toDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { ResourceSet } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { basename, dirname } from '@codingame/monaco-vscode-api/vscode/vs/base/common/path';
import { isMacintosh } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { EditorExtensionsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorExtensions';
import { CodeEditorWidget } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/widget/codeEditor/codeEditorWidget';
import { EditorOptions } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/config/editorOptions';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { isLocation } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { ILanguageService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/language';
import { getIconClasses } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/getIconClasses';
import { IModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/model';
import { ITextModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/resolverService';
import { CopyPasteController } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController';
import { DropIntoEditorController } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController';
import { ContentHoverController } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/hover/browser/contentHoverController';
import { GlyphHoverController } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/hover/browser/glyphHoverController';
import { LinkDetector } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/links/browser/links';
import { SuggestController } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/suggest/browser/suggestController';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { IAccessibilityService } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibility/common/accessibility.service';
import { MenuWorkbenchButtonBar } from '../../../../platform/actions/browser/buttonbar.js';
import { DropdownWithPrimaryActionViewItem } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/browser/dropdownWithPrimaryActionViewItem';
import { getFlatActionBarActions, MenuEntryActionViewItem } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/browser/menuEntryActionViewItem';
import { MenuWorkbenchToolBar, HiddenItemStrategy } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/browser/toolbar';
import { MenuId, MenuItemAction } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { IMenuService } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions.service';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { IContextMenuService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextview/browser/contextView.service';
import { FileKind } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { registerAndCreateHistoryNavigationContext } from '@codingame/monaco-vscode-api/vscode/vs/platform/history/browser/contextScopedHistoryWidget';
import { IHoverService } from '@codingame/monaco-vscode-api/vscode/vs/platform/hover/browser/hover.service';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { ServiceCollection } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/serviceCollection';
import { IKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybinding.service';
import { ILabelService } from '@codingame/monaco-vscode-api/vscode/vs/platform/label/common/label.service';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { FolderThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/themeService';
import { IThemeService } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/themeService.service';
import { ResourceLabels } from '@codingame/monaco-vscode-91789cdf-e3cb-5a04-aaeb-6f7df7d3d231-common/vscode/vs/workbench/browser/labels';
import { SIDE_GROUP, ACTIVE_GROUP } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { AccessibilityVerbositySettingId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/accessibility/browser/accessibilityConfiguration';
import { AccessibilityCommandId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/accessibility/common/accessibilityCommands';
import { getSimpleEditorOptions, getSimpleCodeEditorWidgetOptions, setupSimpleEditorSelectionStyling } from '@codingame/monaco-vscode-b4efa70b-52b9-5670-ab5c-f10b10b6834e-common/vscode/vs/workbench/contrib/codeEditor/browser/simpleEditorOptions';
import { revealInSideBarCommand } from '@codingame/monaco-vscode-5945a5e2-a66c-5a82-bd2c-1965724b29eb-common/vscode/vs/workbench/contrib/files/browser/fileActions.contribution';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { IChatAgentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents.service';
import { ChatContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatContextKeys';
import { ChatEditingSessionState, WorkingSetEntryState, WorkingSetEntryRemovalReason } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService.service';
import { isPasteVariableEntry } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatModel';
import { ChatRequestDynamicVariablePart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatParserTypes';
import { IChatVariablesService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatVariables.service';
import { ChatInputHistoryMaxEntries } from '../common/chatWidgetHistoryService.js';
import { IChatWidgetHistoryService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatWidgetHistoryService.service';
import { ILanguageModelsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/languageModels.service';
import { ChatSubmitAction, CancelAction, ChatModelPickerActionId, ToggleAgentModeActionId, ChatSubmitSecondaryAgentAction } from './actions/chatExecuteActions.js';
import { ImplicitContextAttachmentWidget } from './attachments/implicitContextAttachment.js';
import { InstructionAttachmentsWidget } from './attachments/instructionsAttachment/instructionAttachments.js';
import { EditsAttachmentModel, ChatAttachmentModel } from './chatAttachmentModel.js';
import { toChatVariable } from './chatAttachmentModel/chatInstructionAttachmentsModel.js';
import { hookUpResourceAttachmentDragAndContextMenu, hookUpSymbolAttachmentDragAndContextMenu } from './chatContentParts/chatAttachmentsContentPart.js';
import { CollapsibleListPool } from './chatContentParts/chatReferencesContentPart.js';
import { EditsDragAndDrop, ChatDragAndDrop } from './chatDragAndDrop.js';
import { ChatEditingShowChangesAction, ChatEditingRemoveAllFilesAction } from './chatEditing/chatEditingActions.js';
import { ChatFollowups } from './chatFollowups.js';
import { ChatFileReference } from './contrib/chatDynamicVariables/chatFileReference.js';
import { ChatImplicitContext } from './contrib/chatImplicitContext.js';

var ChatInputPart_1;
const $ = $$1;
const INPUT_EDITOR_MAX_HEIGHT = 250;
let ChatInputPart = class ChatInputPart extends Disposable {
    static { ChatInputPart_1 = this; }
    static { this.INPUT_SCHEME = 'chatSessionInput'; }
    static { this._counter = 0; }
    get attachmentModel() {
        return this._attachmentModel;
    }
    getAttachedAndImplicitContext(sessionId) {
        const contextArr = [...this.attachmentModel.attachments];
        if (this.implicitContext?.enabled && this.implicitContext.value) {
            contextArr.push(this.implicitContext.toBaseEntry());
        }
        const linkOccurrences = this.inputEditor.getContribution(LinkDetector.ID)?.getAllLinkOccurrences() ?? [];
        const linksSeen = ( new Set());
        for (const linkOccurrence of linkOccurrences) {
            const link = linkOccurrence.link;
            const uri = URI.isUri(link.url) ? link.url : link.url ? ( URI.parse(link.url)) : undefined;
            if (!uri || ( linksSeen.has(( uri.toString())))) {
                continue;
            }
            linksSeen.add(( uri.toString()));
            contextArr.push({
                kind: 'link',
                id: ( uri.toString()),
                name: uri.fsPath,
                value: uri,
                isFile: false,
                isDynamic: true,
            });
        }
        const variables = this.variableService.getDynamicVariables(sessionId);
        for (const variable of variables) {
            if (!(variable instanceof ChatFileReference)) {
                continue;
            }
            contextArr.push(...( variable.allValidReferences.map((link) => {
                return toChatVariable(link, false);
            })));
            contextArr.push(toChatVariable(variable, true));
        }
        contextArr
            .push(...this.instructionAttachmentsPart.chatAttachments);
        return contextArr;
    }
    get hasInstructionAttachments() {
        return !this.instructionAttachmentsPart.empty;
    }
    get implicitContext() {
        return this._implicitContext;
    }
    get inputPartHeight() {
        return this._inputPartHeight;
    }
    get followupsHeight() {
        return this._followupsHeight;
    }
    get editSessionWidgetHeight() {
        return this._editSessionWidgetHeight;
    }
    get inputEditor() {
        return this._inputEditor;
    }
    get currentLanguageModel() {
        return this._currentLanguageModel?.identifier;
    }
    get selectedElements() {
        const edits = [];
        const editsList = this._chatEditList?.object;
        const selectedElements = editsList?.getSelectedElements() ?? [];
        for (const element of selectedElements) {
            if (element.kind === 'reference' && URI.isUri(element.reference)) {
                edits.push(element.reference);
            }
        }
        return edits;
    }
    get attemptedWorkingSetEntriesCount() {
        return this._attemptedWorkingSetEntriesCount;
    }
    get chatEditWorkingSetFiles() {
        return this._combinedChatEditWorkingSetEntries;
    }
    constructor(
    location, options, styles, getContribsInputState, historyService, modelService, languageService, instantiationService, contextKeyService, configurationService, keybindingService, accessibilityService, languageModelsService, logService, hoverService, fileService, commandService, editorService, openerService, chatEditingService, themeService, textModelResolverService, storageService, labelService, variableService, chatAgentService) {
        super();
        this.location = location;
        this.options = options;
        this.historyService = historyService;
        this.modelService = modelService;
        this.languageService = languageService;
        this.instantiationService = instantiationService;
        this.contextKeyService = contextKeyService;
        this.configurationService = configurationService;
        this.keybindingService = keybindingService;
        this.accessibilityService = accessibilityService;
        this.languageModelsService = languageModelsService;
        this.logService = logService;
        this.hoverService = hoverService;
        this.fileService = fileService;
        this.commandService = commandService;
        this.editorService = editorService;
        this.openerService = openerService;
        this.chatEditingService = chatEditingService;
        this.themeService = themeService;
        this.textModelResolverService = textModelResolverService;
        this.storageService = storageService;
        this.labelService = labelService;
        this.variableService = variableService;
        this.chatAgentService = chatAgentService;
        this._onDidLoadInputState = this._register(( new Emitter()));
        this.onDidLoadInputState = this._onDidLoadInputState.event;
        this._onDidChangeHeight = this._register(( new Emitter()));
        this.onDidChangeHeight = this._onDidChangeHeight.event;
        this._onDidFocus = this._register(( new Emitter()));
        this.onDidFocus = this._onDidFocus.event;
        this._onDidBlur = this._register(( new Emitter()));
        this.onDidBlur = this._onDidBlur.event;
        this._onDidChangeContext = this._register(( new Emitter()));
        this.onDidChangeContext = this._onDidChangeContext.event;
        this._onDidAcceptFollowup = this._register(( new Emitter()));
        this.onDidAcceptFollowup = this._onDidAcceptFollowup.event;
        this._indexOfLastAttachedContextDeletedWithKeyboard = -1;
        this._onDidChangeVisibility = this._register(( new Emitter()));
        this._contextResourceLabels = this.instantiationService.createInstance(ResourceLabels, { onDidChangeVisibility: this._onDidChangeVisibility.event });
        this.inputEditorHeight = 0;
        this.followupsDisposables = this._register(( new DisposableStore()));
        this.attachedContextDisposables = this._register(( new MutableDisposable()));
        this._inputPartHeight = 0;
        this._followupsHeight = 0;
        this._editSessionWidgetHeight = 0;
        this._waitForPersistedLanguageModel = this._register(( new MutableDisposable()));
        this._onDidChangeCurrentLanguageModel = this._register(( new Emitter()));
        this.inputUri = ( URI.parse(`${ChatInputPart_1.INPUT_SCHEME}:input-${ChatInputPart_1._counter++}`));
        this._chatEditsActionsDisposables = this._register(( new DisposableStore()));
        this._chatEditsDisposables = this._register(( new DisposableStore()));
        this._chatEditsFileLimitHover = this._register(( new MutableDisposable()));
        this._attemptedWorkingSetEntriesCount = 0;
        this._combinedChatEditWorkingSetEntries = [];
        if (this.location === ChatAgentLocation.EditingSession) {
            this._attachmentModel = this._register(this.instantiationService.createInstance(EditsAttachmentModel));
            this.dnd = this._register(this.instantiationService.createInstance(EditsDragAndDrop, this.attachmentModel, styles));
        }
        else {
            this._attachmentModel = this._register(this.instantiationService.createInstance(ChatAttachmentModel));
            this.dnd = this._register(this.instantiationService.createInstance(ChatDragAndDrop, this.attachmentModel, styles));
        }
        this.getInputState = () => {
            return {
                ...getContribsInputState(),
                chatContextAttachments: this._attachmentModel.attachments,
            };
        };
        this.inputEditorMaxHeight = this.options.renderStyle === 'compact' ? INPUT_EDITOR_MAX_HEIGHT / 3 : INPUT_EDITOR_MAX_HEIGHT;
        this.inputEditorHasText = ChatContextKeys.inputHasText.bindTo(contextKeyService);
        this.chatCursorAtTop = ChatContextKeys.inputCursorAtTop.bindTo(contextKeyService);
        this.inputEditorHasFocus = ChatContextKeys.inputHasFocus.bindTo(contextKeyService);
        this.promptInstructionsAttached = ChatContextKeys.instructionsAttached.bindTo(contextKeyService);
        this.history = this.loadHistory();
        this._register(this.historyService.onDidClearHistory(() => this.history = ( new HistoryNavigator2([{ text: '' }], ChatInputHistoryMaxEntries, historyKeyFn))));
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(AccessibilityVerbositySettingId.Chat)) {
                this.inputEditor.updateOptions({ ariaLabel: this._getAriaLabel() });
            }
        }));
        this._chatEditsListPool = this._register(this.instantiationService.createInstance(CollapsibleListPool, this._onDidChangeVisibility.event, MenuId.ChatEditingWidgetModifiedFilesToolbar));
        this._hasFileAttachmentContextKey = ChatContextKeys.hasFileAttachments.bindTo(contextKeyService);
        this.instructionAttachmentsPart = this._register(instantiationService.createInstance(InstructionAttachmentsWidget, this.attachmentModel.promptInstructions, this._contextResourceLabels));
        this.instructionAttachmentsPart.onAttachmentsCountChange(() => {
            this._onDidChangeHeight.fire();
        });
        this.initSelectedModel();
    }
    getSelectedModelStorageKey() {
        return `chat.currentLanguageModel.${this.location}`;
    }
    initSelectedModel() {
        const persistedSelection = this.storageService.get(this.getSelectedModelStorageKey(), StorageScope.APPLICATION);
        if (persistedSelection) {
            const model = this.languageModelsService.lookupLanguageModel(persistedSelection);
            if (model) {
                this._currentLanguageModel = { metadata: model, identifier: persistedSelection };
                this._onDidChangeCurrentLanguageModel.fire(this._currentLanguageModel);
            }
            else {
                this._waitForPersistedLanguageModel.value = this.languageModelsService.onDidChangeLanguageModels(e => {
                    const persistedModel = e.added?.find(m => m.identifier === persistedSelection);
                    if (persistedModel) {
                        this._waitForPersistedLanguageModel.clear();
                        if (persistedModel.metadata.isUserSelectable) {
                            this._currentLanguageModel = { metadata: persistedModel.metadata, identifier: persistedSelection };
                            this._onDidChangeCurrentLanguageModel.fire(this._currentLanguageModel);
                        }
                    }
                });
            }
        }
        this._register(this.chatAgentService.onDidChangeToolsAgentModeEnabled(() => {
            if (this._currentLanguageModel && !this.modelSupportedForDefaultAgent(this._currentLanguageModel)) {
                this.setCurrentLanguageModelToDefault();
            }
        }));
    }
    supportsVision() {
        return this._currentLanguageModel?.metadata.capabilities?.vision ?? false;
    }
    modelSupportedForDefaultAgent(model) {
        if (this.chatAgentService.getDefaultAgent(this.location)?.isToolsAgent) {
            return !!model.metadata.capabilities?.toolCalling && model.metadata.maxInputTokens > 40000;
        }
        return true;
    }
    getModels() {
        const models = ( this.languageModelsService.getLanguageModelIds()
            .map(
            modelId => ({ identifier: modelId, metadata: this.languageModelsService.lookupLanguageModel(modelId) })
        ))
            .filter(entry => entry.metadata?.isUserSelectable && this.modelSupportedForDefaultAgent(entry));
        models.sort((a, b) => a.metadata.name.localeCompare(b.metadata.name));
        return models;
    }
    setCurrentLanguageModelToDefault() {
        const defaultLanguageModelId = this.languageModelsService.getLanguageModelIds().find(id => this.languageModelsService.lookupLanguageModel(id)?.isDefault);
        const hasUserSelectableLanguageModels = this.languageModelsService.getLanguageModelIds().find(id => {
            const model = this.languageModelsService.lookupLanguageModel(id);
            return model?.isUserSelectable && !model.isDefault;
        });
        this._currentLanguageModel = hasUserSelectableLanguageModels && defaultLanguageModelId ?
            { metadata: this.languageModelsService.lookupLanguageModel(defaultLanguageModelId), identifier: defaultLanguageModelId } :
            undefined;
    }
    setCurrentLanguageModelByUser(model) {
        this._currentLanguageModel = model;
        this._waitForPersistedLanguageModel.clear();
        if (this.cachedDimensions) {
            this.layout(this.cachedDimensions.height, this.cachedDimensions.width);
        }
        this.storageService.store(this.getSelectedModelStorageKey(), model.identifier, StorageScope.APPLICATION, StorageTarget.USER);
    }
    loadHistory() {
        const history = this.historyService.getHistory(this.location);
        if (history.length === 0) {
            history.push({ text: '' });
        }
        return ( new HistoryNavigator2(history, 50, historyKeyFn));
    }
    _getAriaLabel() {
        const verbose = this.configurationService.getValue(AccessibilityVerbositySettingId.Chat);
        if (verbose) {
            const kbLabel = this.keybindingService.lookupKeybinding(AccessibilityCommandId.OpenAccessibilityHelp)?.getLabel();
            return kbLabel ? ( localize(
                4544,
                "Chat Input,  Type to ask questions or type / for topics, press enter to send out the request. Use {0} for Chat Accessibility Help.",
                kbLabel
            )) : ( localize(
                4545,
                "Chat Input,  Type code here and press Enter to run. Use the Chat Accessibility Help command for more information."
            ));
        }
        return localize(4546, "Chat Input");
    }
    initForNewChatModel(state) {
        this.history = this.loadHistory();
        this.history.add({
            text: state.inputValue ?? this.history.current().text,
            state: state.inputState ?? this.getInputState()
        });
        const attachments = state.inputState?.chatContextAttachments ?? [];
        this._attachmentModel.clearAndSetContext(...attachments);
        if (state.inputValue) {
            this.setValue(state.inputValue, false);
        }
    }
    logInputHistory() {
        const historyStr = ( [...this.history].map(entry => JSON.stringify(entry))).join('\n');
        this.logService.info(`[${this.location}] Chat input history:`, historyStr);
    }
    setVisible(visible) {
        this._onDidChangeVisibility.fire(visible);
    }
    get element() {
        return this.container;
    }
    showPreviousValue() {
        const inputState = this.getInputState();
        if (this.history.isAtEnd()) {
            this.saveCurrentValue(inputState);
        }
        else {
            if (!( this.history.has({ text: this._inputEditor.getValue(), state: inputState }))) {
                this.saveCurrentValue(inputState);
                this.history.resetCursor();
            }
        }
        this.navigateHistory(true);
    }
    showNextValue() {
        const inputState = this.getInputState();
        if (this.history.isAtEnd()) {
            return;
        }
        else {
            if (!( this.history.has({ text: this._inputEditor.getValue(), state: inputState }))) {
                this.saveCurrentValue(inputState);
                this.history.resetCursor();
            }
        }
        this.navigateHistory(false);
    }
    navigateHistory(previous) {
        const historyEntry = previous ?
            this.history.previous() : this.history.next();
        const historyAttachments = historyEntry.state?.chatContextAttachments ?? [];
        this._attachmentModel.clearAndSetContext(...historyAttachments);
        status(historyEntry.text);
        this.setValue(historyEntry.text, true);
        this._onDidLoadInputState.fire(historyEntry.state);
        const model = this._inputEditor.getModel();
        if (!model) {
            return;
        }
        if (previous) {
            const endOfFirstViewLine = this._inputEditor._getViewModel()?.getLineLength(1) ?? 1;
            const endOfFirstModelLine = model.getLineLength(1);
            if (endOfFirstViewLine === endOfFirstModelLine) {
                this._inputEditor.setPosition({ lineNumber: 1, column: endOfFirstViewLine + 1 });
            }
            else {
                this._inputEditor.setPosition({ lineNumber: 1, column: endOfFirstViewLine });
            }
        }
        else {
            this._inputEditor.setPosition(getLastPosition(model));
        }
    }
    setValue(value, transient) {
        this.inputEditor.setValue(value);
        this.inputEditor.setPosition({ lineNumber: 1, column: value.length + 1 });
        if (!transient) {
            this.saveCurrentValue(this.getInputState());
        }
    }
    saveCurrentValue(inputState) {
        inputState.chatContextAttachments = inputState.chatContextAttachments?.filter(attachment => !attachment.isImage);
        const newEntry = { text: this._inputEditor.getValue(), state: inputState };
        this.history.replaceLast(newEntry);
    }
    focus() {
        this._inputEditor.focus();
    }
    hasFocus() {
        return this._inputEditor.hasWidgetFocus();
    }
    async acceptInput(isUserQuery) {
        if (isUserQuery) {
            const userQuery = this._inputEditor.getValue();
            const inputState = this.getInputState();
            inputState.chatContextAttachments = inputState.chatContextAttachments?.filter(attachment => !attachment.isImage);
            const entry = { text: userQuery, state: inputState };
            this.history.replaceLast(entry);
            this.history.add({ text: '' });
        }
        this.attachmentModel.clear();
        this._onDidLoadInputState.fire({});
        if (this.accessibilityService.isScreenReaderOptimized() && isMacintosh) {
            this._acceptInputForVoiceover();
        }
        else {
            this._inputEditor.focus();
            this._inputEditor.setValue('');
        }
    }
    _acceptInputForVoiceover() {
        const domNode = this._inputEditor.getDomNode();
        if (!domNode) {
            return;
        }
        domNode.remove();
        this._inputEditor.setValue('');
        this._inputEditorElement.appendChild(domNode);
        this._inputEditor.focus();
    }
    _handleAttachedContextChange() {
        this._hasFileAttachmentContextKey.set(Boolean(this._attachmentModel.attachments.find(a => a.isFile)));
        this.renderAttachedContext();
    }
    render(container, initialValue, widget) {
        let elements;
        if (this.options.renderStyle === 'compact') {
            elements = h('.interactive-input-part', [
                h('.interactive-input-and-edit-session', [
                    h('.chat-editing-session@chatEditingSessionWidgetContainer'),
                    h('.interactive-input-and-side-toolbar@inputAndSideToolbar', [
                        h('.chat-input-container@inputContainer', [
                            h('.chat-editor-container@editorContainer'),
                            h('.chat-input-toolbars@inputToolbars'),
                        ]),
                    ]),
                    h('.chat-attached-context@attachedContextContainer'),
                    h('.interactive-input-followups@followupsContainer'),
                ])
            ]);
        }
        else {
            elements = h('.interactive-input-part', [
                h('.interactive-input-followups@followupsContainer'),
                h('.chat-editing-session@chatEditingSessionWidgetContainer'),
                h('.interactive-input-and-side-toolbar@inputAndSideToolbar', [
                    h('.chat-input-container@inputContainer', [
                        h('.chat-editor-container@editorContainer'),
                        h('.chat-attached-context@attachedContextContainer'),
                        h('.chat-input-toolbars@inputToolbars'),
                    ]),
                ]),
            ]);
        }
        this.container = elements.root;
        container.append(this.container);
        this.container.classList.toggle('compact', this.options.renderStyle === 'compact');
        this.followupsContainer = elements.followupsContainer;
        const inputAndSideToolbar = elements.inputAndSideToolbar;
        const inputContainer = elements.inputContainer;
        const editorContainer = elements.editorContainer;
        this.attachedContextContainer = elements.attachedContextContainer;
        const toolbarsContainer = elements.inputToolbars;
        this.chatEditingSessionWidgetContainer = elements.chatEditingSessionWidgetContainer;
        this.renderAttachedContext();
        if (this.options.enableImplicitContext) {
            this._implicitContext = this._register(( new ChatImplicitContext()));
            this._register(this._implicitContext.onDidChangeValue(() => this._handleAttachedContextChange()));
        }
        this._register(this._attachmentModel.onDidChangeContext(() => this._handleAttachedContextChange()));
        this.renderChatEditingSessionState(null, widget);
        this.dnd.addOverlay(container, container);
        const inputScopedContextKeyService = this._register(this.contextKeyService.createScoped(inputContainer));
        ChatContextKeys.inChatInput.bindTo(inputScopedContextKeyService).set(true);
        const scopedInstantiationService = this._register(this.instantiationService.createChild(( new ServiceCollection([IContextKeyService, inputScopedContextKeyService]))));
        const { historyNavigationBackwardsEnablement, historyNavigationForwardsEnablement } = this._register(registerAndCreateHistoryNavigationContext(inputScopedContextKeyService, this));
        this.historyNavigationBackwardsEnablement = historyNavigationBackwardsEnablement;
        this.historyNavigationForewardsEnablement = historyNavigationForwardsEnablement;
        const options = getSimpleEditorOptions(this.configurationService);
        options.overflowWidgetsDomNode = this.options.editorOverflowWidgetsDomNode;
        options.pasteAs = EditorOptions.pasteAs.defaultValue;
        options.readOnly = false;
        options.ariaLabel = this._getAriaLabel();
        options.fontFamily = DEFAULT_FONT_FAMILY;
        options.fontSize = 13;
        options.lineHeight = 20;
        options.padding = this.options.renderStyle === 'compact' ? { top: 2, bottom: 2 } : { top: 8, bottom: 8 };
        options.cursorWidth = 1;
        options.wrappingStrategy = 'advanced';
        options.bracketPairColorization = { enabled: false };
        options.suggest = {
            showIcons: false,
            showSnippets: false,
            showWords: true,
            showStatusBar: false,
            insertMode: 'replace',
        };
        options.scrollbar = { ...(options.scrollbar ?? {}), vertical: 'hidden' };
        options.stickyScroll = { enabled: false };
        this._inputEditorElement = append(editorContainer, $(chatInputEditorContainerSelector));
        const editorOptions = getSimpleCodeEditorWidgetOptions();
        editorOptions.contributions?.push(...EditorExtensionsRegistry.getSomeEditorContributions([ContentHoverController.ID, GlyphHoverController.ID, CopyPasteController.ID, LinkDetector.ID]));
        this._inputEditor = this._register(scopedInstantiationService.createInstance(CodeEditorWidget, this._inputEditorElement, options, editorOptions));
        SuggestController.get(this._inputEditor)?.forceRenderingAbove();
        this._register(this._inputEditor.onDidChangeModelContent(() => {
            const currentHeight = Math.min(this._inputEditor.getContentHeight(), this.inputEditorMaxHeight);
            if (currentHeight !== this.inputEditorHeight) {
                this.inputEditorHeight = currentHeight;
                this._onDidChangeHeight.fire();
            }
            const model = this._inputEditor.getModel();
            const inputHasText = !!model && model.getValue().trim().length > 0;
            this.inputEditorHasText.set(inputHasText);
        }));
        this._register(this._inputEditor.onDidContentSizeChange(e => {
            if (e.contentHeightChanged) {
                this.inputEditorHeight = e.contentHeight;
                this._onDidChangeHeight.fire();
            }
        }));
        this._register(this._inputEditor.onDidFocusEditorText(() => {
            this.inputEditorHasFocus.set(true);
            this._onDidFocus.fire();
            inputContainer.classList.toggle('focused', true);
        }));
        this._register(this._inputEditor.onDidBlurEditorText(() => {
            this.inputEditorHasFocus.set(false);
            inputContainer.classList.toggle('focused', false);
            this._onDidBlur.fire();
        }));
        this._register(this._inputEditor.onDidBlurEditorWidget(() => {
            CopyPasteController.get(this._inputEditor)?.clearWidgets();
            DropIntoEditorController.get(this._inputEditor)?.clearWidgets();
        }));
        const hoverDelegate = this._register(createInstantHoverDelegate());
        this._register(addStandardDisposableListener(toolbarsContainer, EventType.CLICK, e => this.inputEditor.focus()));
        this.inputActionsToolbar = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, toolbarsContainer, MenuId.ChatInput, {
            telemetrySource: this.options.menus.telemetrySource,
            menuOptions: { shouldForwardArgs: true },
            hiddenItemStrategy: HiddenItemStrategy.Ignore,
            hoverDelegate
        }));
        this.inputActionsToolbar.context = { widget };
        this._register(this.inputActionsToolbar.onDidChangeMenuItems(() => {
            if (this.cachedDimensions && typeof this.cachedInputToolbarWidth === 'number' && this.cachedInputToolbarWidth !== this.inputActionsToolbar.getItemsWidth()) {
                this.layout(this.cachedDimensions.height, this.cachedDimensions.width);
            }
        }));
        this.executeToolbar = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, toolbarsContainer, this.options.menus.executeToolbar, {
            telemetrySource: this.options.menus.telemetrySource,
            menuOptions: {
                shouldForwardArgs: true
            },
            hoverDelegate,
            hiddenItemStrategy: HiddenItemStrategy.Ignore,
            actionViewItemProvider: (action, options) => {
                if (this.location === ChatAgentLocation.Panel || this.location === ChatAgentLocation.Editor) {
                    if ((action.id === ChatSubmitAction.ID || action.id === CancelAction.ID) && action instanceof MenuItemAction) {
                        const dropdownAction = this.instantiationService.createInstance(MenuItemAction, { id: 'chat.moreExecuteActions', title: ( localize(4547, "More...")), icon: Codicon.chevronDown }, undefined, undefined, undefined, undefined);
                        return this.instantiationService.createInstance(ChatSubmitDropdownActionItem, action, dropdownAction, options);
                    }
                }
                if (action.id === ChatModelPickerActionId && action instanceof MenuItemAction) {
                    if (!this._currentLanguageModel) {
                        this.setCurrentLanguageModelToDefault();
                    }
                    if (this._currentLanguageModel) {
                        const itemDelegate = {
                            onDidChangeModel: this._onDidChangeCurrentLanguageModel.event,
                            setModel: (model) => {
                                this.setCurrentLanguageModelByUser(model);
                                this.renderAttachedContext();
                            },
                            getModels: () => this.getModels()
                        };
                        return this.instantiationService.createInstance(ModelPickerActionViewItem, action, this._currentLanguageModel, itemDelegate, { hoverDelegate: options.hoverDelegate, keybinding: options.keybinding ?? undefined });
                    }
                }
                else if (action.id === ToggleAgentModeActionId && action instanceof MenuItemAction) {
                    return this.instantiationService.createInstance(ToggleAgentActionViewItem, action, options);
                }
                return undefined;
            }
        }));
        this.executeToolbar.getElement().classList.add('chat-execute-toolbar');
        this.executeToolbar.context = { widget };
        this._register(this.executeToolbar.onDidChangeMenuItems(() => {
            if (this.cachedDimensions && typeof this.cachedExecuteToolbarWidth === 'number' && this.cachedExecuteToolbarWidth !== this.executeToolbar.getItemsWidth()) {
                this.layout(this.cachedDimensions.height, this.cachedDimensions.width);
            }
        }));
        if (this.options.menus.inputSideToolbar) {
            const toolbarSide = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, inputAndSideToolbar, this.options.menus.inputSideToolbar, {
                telemetrySource: this.options.menus.telemetrySource,
                menuOptions: {
                    shouldForwardArgs: true
                },
                hoverDelegate
            }));
            this.inputSideToolbarContainer = toolbarSide.getElement();
            toolbarSide.getElement().classList.add('chat-side-toolbar');
            toolbarSide.context = { widget };
        }
        let inputModel = this.modelService.getModel(this.inputUri);
        if (!inputModel) {
            inputModel = this.modelService.createModel('', null, this.inputUri, true);
        }
        this.textModelResolverService.createModelReference(this.inputUri).then(ref => {
            if (this._store.isDisposed) {
                ref.dispose();
                return;
            }
            this._register(ref);
        });
        this.inputModel = inputModel;
        this.inputModel.updateOptions({ bracketColorizationOptions: { enabled: false, independentColorPoolPerBracketType: false } });
        this._inputEditor.setModel(this.inputModel);
        if (initialValue) {
            this.inputModel.setValue(initialValue);
            const lineNumber = this.inputModel.getLineCount();
            this._inputEditor.setPosition({ lineNumber, column: this.inputModel.getLineMaxColumn(lineNumber) });
        }
        const onDidChangeCursorPosition = () => {
            const model = this._inputEditor.getModel();
            if (!model) {
                return;
            }
            const position = this._inputEditor.getPosition();
            if (!position) {
                return;
            }
            const atTop = position.lineNumber === 1 && position.column - 1 <= (this._inputEditor._getViewModel()?.getLineLength(1) ?? 0);
            this.chatCursorAtTop.set(atTop);
            this.historyNavigationBackwardsEnablement.set(atTop);
            this.historyNavigationForewardsEnablement.set(position.equals(getLastPosition(model)));
        };
        this._register(this._inputEditor.onDidChangeCursorPosition(e => onDidChangeCursorPosition()));
        onDidChangeCursorPosition();
        this._register(this.themeService.onDidFileIconThemeChange(() => {
            this.renderAttachedContext();
        }));
    }
    async renderAttachedContext() {
        const container = this.attachedContextContainer;
        const oldHeight = container.offsetHeight;
        const store = ( new DisposableStore());
        this.attachedContextDisposables.value = store;
        clearNode(container);
        const hoverDelegate = store.add(createInstantHoverDelegate());
        const attachments = this.location === ChatAgentLocation.EditingSession
            ? [...this.attachmentModel.attachments.entries()].filter(([_, attachment]) => !attachment.isFile || attachment.isFile && typeof attachment.value === 'object' && !!attachment.value && 'range' in attachment.value)
            : [...this.attachmentModel.attachments.entries()];
        setVisibility(Boolean(attachments.length) || Boolean(this.implicitContext?.value) || !this.instructionAttachmentsPart.empty, this.attachedContextContainer);
        if (!attachments.length) {
            this._indexOfLastAttachedContextDeletedWithKeyboard = -1;
        }
        if (this.implicitContext?.value) {
            const implicitPart = store.add(this.instantiationService.createInstance(ImplicitContextAttachmentWidget, this.implicitContext, this._contextResourceLabels));
            container.appendChild(implicitPart.domNode);
        }
        this.promptInstructionsAttached.set(!this.instructionAttachmentsPart.empty);
        container.appendChild(this.instructionAttachmentsPart.domNode);
        const attachmentInitPromises = [];
        for (const [index, attachment] of attachments) {
            const widget = append(container, $('.chat-attached-context-attachment.show-file-icons'));
            const label = this._contextResourceLabels.create(widget, { supportIcons: true, hoverDelegate, hoverTargetOverride: widget });
            let ariaLabel;
            let resource = URI.isUri(attachment.value) ? attachment.value : attachment.value && typeof attachment.value === 'object' && 'uri' in attachment.value && URI.isUri(attachment.value.uri) ? attachment.value.uri : undefined;
            let range = attachment.value && typeof attachment.value === 'object' && 'range' in attachment.value && Range.isIRange(attachment.value.range) ? attachment.value.range : undefined;
            if (resource && (attachment.isFile || attachment.isDirectory)) {
                const fileBasename = basename(resource.path);
                const fileDirname = dirname(resource.path);
                const friendlyName = `${fileBasename} ${fileDirname}`;
                ariaLabel = range ? ( localize(
                    4548,
                    "Attached file, {0}, line {1} to line {2}",
                    friendlyName,
                    range.startLineNumber,
                    range.endLineNumber
                )) : ( localize(4549, "Attached file, {0}", friendlyName));
                const fileOptions = { hidePath: true };
                label.setFile(resource, attachment.isFile ? {
                    ...fileOptions,
                    fileKind: FileKind.FILE,
                    range,
                } : {
                    ...fileOptions,
                    fileKind: FileKind.FOLDER,
                    icon: !this.themeService.getFileIconTheme().hasFolderIcons ? FolderThemeIcon : undefined
                });
                this.attachButtonAndDisposables(widget, index, attachment, hoverDelegate);
                this.instantiationService.invokeFunction(accessor => {
                    if (resource) {
                        store.add(hookUpResourceAttachmentDragAndContextMenu(accessor, widget, resource));
                    }
                });
            }
            else if (attachment.isImage) {
                ariaLabel = ( localize(4550, "Attached image, {0}", attachment.name));
                const hoverElement = $$1('div.chat-attached-context-hover');
                hoverElement.setAttribute('aria-label', ariaLabel);
                const supportsVision = this.supportsVision();
                const pillIcon = $$1('div.chat-attached-context-pill', {}, $$1(supportsVision ? 'span.codicon.codicon-file-media' : 'span.codicon.codicon-warning'));
                const textLabel = $$1('span.chat-attached-context-custom-text', {}, attachment.name);
                widget.appendChild(pillIcon);
                widget.appendChild(textLabel);
                if (attachment.references) {
                    widget.style.cursor = 'pointer';
                    const clickHandler = () => {
                        if (attachment.references && URI.isUri(attachment.references[0].reference)) {
                            this.openResource(attachment.references[0].reference, false, undefined);
                        }
                    };
                    store.add(addDisposableListener(widget, 'click', clickHandler));
                }
                if (!supportsVision) {
                    widget.classList.add('warning');
                    hoverElement.textContent = ( localize(
                        4551,
                        "{0} does not support images.",
                        this.currentLanguageModel ? this.languageModelsService.lookupLanguageModel(this.currentLanguageModel)?.name : this.currentLanguageModel
                    ));
                    textLabel.style.textDecoration = 'line-through';
                    store.add(this.hoverService.setupManagedHover(hoverDelegate, widget, hoverElement, { trapFocus: true }));
                    this.attachButtonAndDisposables(widget, index, attachment, hoverDelegate);
                }
                else {
                    attachmentInitPromises.push(Promises.withAsyncBody(async (resolve) => {
                        let buffer;
                        try {
                            this.attachButtonAndDisposables(widget, index, attachment, hoverDelegate);
                            if (attachment.value instanceof URI) {
                                const readFile = await this.fileService.readFile(attachment.value);
                                if (store.isDisposed) {
                                    return;
                                }
                                buffer = readFile.value.buffer;
                            }
                            else {
                                buffer = attachment.value;
                            }
                            this.createImageElements(buffer, widget, hoverElement);
                        }
                        catch (error) {
                            console.error('Error processing attachment:', error);
                        }
                        store.add(this.hoverService.setupManagedHover(hoverDelegate, widget, hoverElement, { trapFocus: false }));
                        resolve();
                    }));
                }
                widget.style.position = 'relative';
            }
            else if (isPasteVariableEntry(attachment)) {
                ariaLabel = ( localize(4552, "Attached context, {0}", attachment.name));
                const classNames = ['file-icon', `${attachment.language}-lang-file-icon`];
                if (attachment.copiedFrom) {
                    resource = attachment.copiedFrom.uri;
                    range = attachment.copiedFrom.range;
                    const filename = basename(resource.path);
                    label.setLabel(filename, undefined, { extraClasses: classNames });
                }
                else {
                    label.setLabel(attachment.fileName, undefined, { extraClasses: classNames });
                }
                widget.appendChild($$1('span.attachment-additional-info', {}, `Pasted ${attachment.pastedLines}`));
                widget.style.position = 'relative';
                const hoverContent = {
                    markdown: {
                        value: `${attachment.copiedFrom ? this.labelService.getUriLabel(attachment.copiedFrom.uri, { relative: true }) : attachment.fileName}\n\n---\n\n\`\`\`${attachment.language}\n\n${attachment.code}\n\`\`\``,
                    },
                    markdownNotSupportedFallback: attachment.code,
                };
                store.add(this.hoverService.setupManagedHover(hoverDelegate, widget, hoverContent, { trapFocus: true }));
                this.attachButtonAndDisposables(widget, index, attachment, hoverDelegate);
                const copiedFromResource = attachment.copiedFrom?.uri;
                if (copiedFromResource) {
                    store.add(this.instantiationService.invokeFunction(accessor => hookUpResourceAttachmentDragAndContextMenu(accessor, widget, copiedFromResource)));
                }
            }
            else {
                const attachmentLabel = attachment.fullName ?? attachment.name;
                const withIcon = attachment.icon?.id ? `$(${attachment.icon.id}) ${attachmentLabel}` : attachmentLabel;
                label.setLabel(withIcon, undefined);
                ariaLabel = ( localize(4552, "Attached context, {0}", attachment.name));
                this.attachButtonAndDisposables(widget, index, attachment, hoverDelegate);
            }
            if (attachment.kind === 'symbol') {
                const scopedContextKeyService = store.add(this.contextKeyService.createScoped(widget));
                store.add(this.instantiationService.invokeFunction(accessor => hookUpSymbolAttachmentDragAndContextMenu(accessor, widget, scopedContextKeyService, { ...attachment, kind: attachment.symbolKind }, MenuId.ChatInputSymbolAttachmentContext)));
            }
            await Promise.all(attachmentInitPromises);
            if (store.isDisposed) {
                return;
            }
            if (resource) {
                widget.style.cursor = 'pointer';
                store.add(addDisposableListener(widget, EventType.CLICK, (e) => {
                    EventHelper.stop(e, true);
                    if (attachment.isDirectory) {
                        this.openResource(resource, true);
                    }
                    else {
                        this.openResource(resource, false, range);
                    }
                }));
                store.add(addDisposableListener(widget, EventType.KEY_DOWN, (e) => {
                    const event = ( new StandardKeyboardEvent(e));
                    if (event.equals(KeyCode.Enter) || event.equals(KeyCode.Space)) {
                        EventHelper.stop(e, true);
                        if (attachment.isDirectory) {
                            this.openResource(resource, true);
                        }
                        else {
                            this.openResource(resource, false, range);
                        }
                    }
                }));
            }
            widget.tabIndex = 0;
            widget.ariaLabel = ariaLabel;
        }
        if (oldHeight !== container.offsetHeight) {
            this._onDidChangeHeight.fire();
        }
    }
    openResource(resource, isDirectory, range) {
        if (isDirectory) {
            this.commandService.executeCommand(revealInSideBarCommand.id, resource);
            return;
        }
        const openTextEditorOptions = range ? { selection: range } : undefined;
        const options = {
            fromUserGesture: true,
            editorOptions: openTextEditorOptions,
        };
        this.openerService.open(resource, options);
    }
    attachButtonAndDisposables(widget, index, attachment, hoverDelegate) {
        const store = this.attachedContextDisposables.value;
        if (!store) {
            return;
        }
        const clearButton = ( new Button(widget, {
            supportIcons: true,
            hoverDelegate,
            title: ( localize(4553, "Remove from context"))
        }));
        if (index === Math.min(this._indexOfLastAttachedContextDeletedWithKeyboard, this.attachmentModel.size - 1)) {
            clearButton.focus();
        }
        store.add(clearButton);
        clearButton.icon = Codicon.close;
        store.add(Event.once(clearButton.onDidClick)((e) => {
            this._attachmentModel.delete(attachment.id);
            if (isKeyboardEvent(e)) {
                const event = ( new StandardKeyboardEvent(e));
                if (event.equals(KeyCode.Enter) || event.equals(KeyCode.Space)) {
                    this._indexOfLastAttachedContextDeletedWithKeyboard = index;
                }
            }
            if (this._attachmentModel.size === 0) {
                this.focus();
            }
            this._onDidChangeContext.fire({ removed: [attachment] });
        }));
    }
    createImageElements(buffer, widget, hoverElement) {
        const blob = ( new Blob([buffer], { type: 'image/png' }));
        const url = URL.createObjectURL(blob);
        const pillImg = $$1('img.chat-attached-context-pill-image', { src: url, alt: '' });
        const pill = $$1('div.chat-attached-context-pill', {}, pillImg);
        const existingPill = widget.querySelector('.chat-attached-context-pill');
        if (existingPill) {
            existingPill.replaceWith(pill);
        }
        const hoverImage = $$1('img.chat-attached-context-image', { src: url, alt: '' });
        hoverElement.appendChild(hoverImage);
        hoverImage.onload = () => {
            URL.revokeObjectURL(url);
        };
    }
    async renderChatEditingSessionState(chatEditingSession, chatWidget) {
        setVisibility(Boolean(chatEditingSession), this.chatEditingSessionWidgetContainer);
        if (!chatEditingSession || !this.options.renderWorkingSet) {
            clearNode(this.chatEditingSessionWidgetContainer);
            this._chatEditsDisposables.clear();
            this._chatEditList = undefined;
            this._combinedChatEditWorkingSetEntries = [];
            this._chatEditsProgress?.dispose();
            return;
        }
        const currentChatEditingState = chatEditingSession.state.get();
        if (this._chatEditList && !chatWidget?.viewModel?.requestInProgress && (currentChatEditingState === ChatEditingSessionState.Idle || currentChatEditingState === ChatEditingSessionState.Initial)) {
            this._chatEditsProgress?.stop();
        }
        const innerContainer = this.chatEditingSessionWidgetContainer.querySelector('.chat-editing-session-container.show-file-icons') ?? append(this.chatEditingSessionWidgetContainer, $('.chat-editing-session-container.show-file-icons'));
        const seenEntries = ( new ResourceSet());
        let entries = chatEditingSession?.entries.get().map((entry) => {
            seenEntries.add(entry.modifiedURI);
            return {
                reference: entry.modifiedURI,
                state: entry.state.get(),
                kind: 'reference',
            };
        }) ?? [];
        for (const attachment of this.attachmentModel.fileAttachments) {
            if (URI.isUri(attachment.value) && !( seenEntries.has(attachment.value))) {
                entries.unshift({
                    reference: attachment.value,
                    state: WorkingSetEntryState.Attached,
                    kind: 'reference',
                });
                seenEntries.add(attachment.value);
            }
        }
        for (const [file, metadata] of chatEditingSession.workingSet.entries()) {
            if (!( seenEntries.has(file)) && metadata.state !== WorkingSetEntryState.Suggested) {
                entries.unshift({
                    reference: file,
                    state: metadata.state,
                    description: metadata.description,
                    kind: 'reference',
                    isMarkedReadonly: metadata.isMarkedReadonly,
                });
                seenEntries.add(file);
            }
        }
        for (const part of chatWidget?.parsedInput.parts ?? []) {
            if (part instanceof ChatRequestDynamicVariablePart && part.isFile && (URI.isUri(part.data) && !( seenEntries.has(part.data)) || isLocation(part.data) && !( seenEntries.has(part.data.uri)))) {
                entries.unshift({
                    reference: part.data,
                    state: WorkingSetEntryState.Attached,
                    kind: 'reference',
                });
            }
        }
        const excludedEntries = [];
        for (const excludedAttachment of this.attachmentModel.excludedFileAttachments) {
            if (excludedAttachment.isFile && URI.isUri(excludedAttachment.value) && !( seenEntries.has(excludedAttachment.value))) {
                excludedEntries.push({
                    reference: excludedAttachment.value,
                    state: WorkingSetEntryState.Attached,
                    kind: 'reference',
                    excluded: true,
                    title: ( localize(
                        4554,
                        'The Working Set file limit has ben reached. {0} is excluded from the Woking Set. Remove other files to make space for {0}.',
                        basename(excludedAttachment.value.path)
                    ))
                });
                seenEntries.add(excludedAttachment.value);
            }
        }
        entries.sort((a, b) => {
            if (a.kind === 'reference' && b.kind === 'reference') {
                if (a.state === b.state || a.state === undefined || b.state === undefined) {
                    return ( a.reference.toString()).localeCompare(( b.reference.toString()));
                }
                return a.state - b.state;
            }
            return 0;
        });
        let remainingFileEntriesBudget = this.chatEditingService.editingSessionFileLimit;
        const overviewRegion = innerContainer.querySelector('.chat-editing-session-overview') ?? append(innerContainer, $('.chat-editing-session-overview'));
        const overviewTitle = overviewRegion.querySelector('.working-set-title') ?? append(overviewRegion, $('.working-set-title'));
        const overviewWorkingSet = overviewTitle.querySelector('span') ?? append(overviewTitle, $('span'));
        const overviewFileCount = overviewTitle.querySelector('span.working-set-count') ?? append(overviewTitle, $('span.working-set-count'));
        overviewWorkingSet.textContent = ( localize(4555, 'Working Set'));
        this._attemptedWorkingSetEntriesCount = entries.length + excludedEntries.length;
        let suggestedFilesInWorkingSetCount = 0;
        overviewFileCount.textContent = '';
        if (entries.length === 1) {
            overviewFileCount.textContent = ' ' + ( localize(4556, '(1 file)'));
            suggestedFilesInWorkingSetCount = entries[0].kind === 'reference' && entries[0].state === WorkingSetEntryState.Suggested ? 1 : 0;
        }
        else if (entries.length >= remainingFileEntriesBudget) {
            const entriesToPreserve = [];
            const newEntries = [];
            const suggestedFiles = [];
            for (let i = 0; i < entries.length; i += 1) {
                const entry = entries[i];
                if (entry.kind !== 'reference' || !URI.isUri(entry.reference)) {
                    continue;
                }
                const currentEntryUri = entry.reference;
                if (entry.state === WorkingSetEntryState.Suggested) {
                    suggestedFiles.push(entry);
                }
                else if (this._combinedChatEditWorkingSetEntries.find((e) => ( e.toString()) === currentEntryUri?.toString())) {
                    if (remainingFileEntriesBudget > 0) {
                        entriesToPreserve.push(entry);
                        remainingFileEntriesBudget -= 1;
                    }
                }
                else {
                    newEntries.push(entry);
                }
            }
            const newEntriesThatFit = remainingFileEntriesBudget > 0 ? newEntries.slice(0, remainingFileEntriesBudget) : [];
            remainingFileEntriesBudget -= newEntriesThatFit.length;
            const suggestedFilesThatFit = remainingFileEntriesBudget > 0 ? suggestedFiles.slice(0, remainingFileEntriesBudget) : [];
            entries = [...entriesToPreserve, ...newEntriesThatFit, ...suggestedFilesThatFit];
            suggestedFilesInWorkingSetCount = suggestedFilesThatFit.length;
        }
        else {
            suggestedFilesInWorkingSetCount = entries.filter(e => e.kind === 'reference' && e.state === WorkingSetEntryState.Suggested).length;
        }
        if (excludedEntries.length > 0) {
            overviewFileCount.textContent = ' ' + ( localize(
                4557,
                '({0}/{1} files)',
                this.chatEditingService.editingSessionFileLimit + excludedEntries.length,
                this.chatEditingService.editingSessionFileLimit
            ));
        }
        else if (entries.length > 1) {
            const fileCount = entries.length - suggestedFilesInWorkingSetCount;
            overviewFileCount.textContent = ' ' + (fileCount === 1 ? ( localize(4556, '(1 file)')) : ( localize(4558, '({0} files)', fileCount)));
        }
        overviewTitle.ariaLabel = overviewWorkingSet.textContent + overviewFileCount.textContent;
        overviewTitle.tabIndex = 0;
        const fileLimitReached = remainingFileEntriesBudget <= 0;
        overviewFileCount.classList.toggle('file-limit-reached', fileLimitReached);
        if (fileLimitReached) {
            let title = ( localize(
                4559,
                'You have reached the maximum number of files that can be added to the working set.'
            ));
            title += excludedEntries.length === 1 ? ' ' + ( localize(4560, '1 file is excluded from the Working Set.')) : '';
            title += excludedEntries.length > 1 ? ' ' + ( localize(
                4561,
                '{0} files are excluded from the Working Set.',
                excludedEntries.length
            )) : '';
            this._chatEditsFileLimitHover.value = getBaseLayerHoverDelegate().setupDelayedHover(overviewFileCount, {
                content: title,
                appearance: { showPointer: true, compact: true },
                position: { hoverPosition: HoverPosition.ABOVE }
            });
        }
        else {
            this._chatEditsFileLimitHover.clear();
        }
        this._chatEditsActionsDisposables.clear();
        const actionsContainer = overviewRegion.querySelector('.chat-editing-session-actions') ?? append(overviewRegion, $('.chat-editing-session-actions'));
        this._chatEditsActionsDisposables.add(this.instantiationService.createInstance(MenuWorkbenchButtonBar, actionsContainer, MenuId.ChatEditingWidgetToolbar, {
            telemetrySource: this.options.menus.telemetrySource,
            menuOptions: {
                arg: { sessionId: chatEditingSession.chatSessionId },
            },
            buttonConfigProvider: (action) => {
                if (action.id === ChatEditingShowChangesAction.ID || action.id === ChatEditingRemoveAllFilesAction.ID) {
                    return { showIcon: true, showLabel: false, isSecondary: true };
                }
                return undefined;
            }
        }));
        if (!chatEditingSession) {
            return;
        }
        if (currentChatEditingState === ChatEditingSessionState.StreamingEdits || chatWidget?.viewModel?.requestInProgress) {
            this._chatEditsProgress?.infinite().show(500);
        }
        const workingSetContainer = innerContainer.querySelector('.chat-editing-session-list') ?? append(innerContainer, $('.chat-editing-session-list'));
        if (!this._chatEditList) {
            this._chatEditList = this._chatEditsListPool.get();
            const list = this._chatEditList.object;
            this._chatEditsDisposables.add(this._chatEditList);
            this._chatEditsDisposables.add(list.onDidFocus(() => {
                this._onDidFocus.fire();
            }));
            this._chatEditsDisposables.add(list.onDidOpen((e) => {
                if (e.element?.kind === 'reference' && URI.isUri(e.element.reference)) {
                    const modifiedFileUri = e.element.reference;
                    const entry = chatEditingSession.getEntry(modifiedFileUri);
                    const diffInfo = entry?.diffInfo.get();
                    const range = diffInfo?.changes.at(0)?.modified.toExclusiveRange();
                    this.editorService.openEditor({
                        resource: modifiedFileUri,
                        options: {
                            ...e.editorOptions,
                            selection: range,
                        }
                    }, e.sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
                }
            }));
            this._chatEditsDisposables.add(addDisposableListener(list.getHTMLElement(), 'click', e => {
                if (!this.hasFocus()) {
                    this._onDidFocus.fire();
                }
            }, true));
            append(workingSetContainer, list.getHTMLElement());
            append(innerContainer, workingSetContainer);
        }
        const maxItemsShown = 6;
        const itemsShown = Math.min(entries.length + excludedEntries.length, maxItemsShown);
        const height = itemsShown * 22;
        const list = this._chatEditList.object;
        list.layout(height);
        list.getHTMLElement().style.height = `${height}px`;
        list.splice(0, list.length, entries);
        list.splice(entries.length, 0, excludedEntries);
        this._combinedChatEditWorkingSetEntries = coalesce(( entries.map(
            (e) => e.kind === 'reference' && URI.isUri(e.reference) ? ({ uri: e.reference, isMarkedReadonly: e.isMarkedReadonly }) : undefined
        )));
        const addFilesElement = innerContainer.querySelector('.chat-editing-session-toolbar-actions') ?? append(innerContainer, $('.chat-editing-session-toolbar-actions'));
        const hoverDelegate = getDefaultHoverDelegate('element');
        const button = this._chatEditsActionsDisposables.add(( new Button(addFilesElement, {
            supportIcons: true,
            secondary: true,
            hoverDelegate
        })));
        button.enabled = remainingFileEntriesBudget > 0;
        button.label = ( localize(4562, '{0} Add Files...', '$(add)'));
        button.setTitle(button.enabled ? ( localize(4563, 'Add files to your working set')) : ( localize(
            4559,
            'You have reached the maximum number of files that can be added to the working set.'
        )));
        this._chatEditsActionsDisposables.add(button.onDidClick(() => {
            this.commandService.executeCommand('workbench.action.chat.editing.attachFiles', { widget: chatWidget });
        }));
        append(addFilesElement, button.element);
        for (const [uri, metadata] of chatEditingSession.workingSet) {
            if (metadata.state !== WorkingSetEntryState.Suggested) {
                continue;
            }
            const addBtn = this._chatEditsActionsDisposables.add(( new Button(addFilesElement, {
                supportIcons: true,
                secondary: true,
                hoverDelegate
            })));
            addBtn.enabled = remainingFileEntriesBudget > 0;
            addBtn.label = this.labelService.getUriBasenameLabel(uri);
            addBtn.element.classList.add('monaco-icon-label', ...getIconClasses(this.modelService, this.languageService, uri, FileKind.FILE));
            addBtn.setTitle(( localize(
                4564,
                "{0} - {1}",
                this.labelService.getUriLabel(uri, { relative: true }),
                metadata.description ?? ''
            )));
            this._chatEditsActionsDisposables.add(addBtn.onDidClick(() => {
                group.remove();
                chatEditingSession.addFileToWorkingSet(uri);
            }));
            const rmBtn = this._chatEditsActionsDisposables.add(( new Button(addFilesElement, {
                supportIcons: false,
                secondary: true,
                hoverDelegate,
                ariaLabel: ( localize(
                    4565,
                    'Remove suggestion {0}',
                    this.labelService.getUriLabel(uri, { relative: true })
                )),
            })));
            rmBtn.icon = Codicon.close;
            rmBtn.setTitle(( localize(4566, 'Remove suggestion')));
            this._chatEditsActionsDisposables.add(rmBtn.onDidClick(() => {
                group.remove();
                chatEditingSession.remove(WorkingSetEntryRemovalReason.User, uri);
            }));
            const sep = document.createElement('div');
            sep.classList.add('separator');
            const group = document.createElement('span');
            group.classList.add('monaco-button-dropdown', 'sidebyside-button');
            group.appendChild(addBtn.element);
            group.appendChild(sep);
            group.appendChild(rmBtn.element);
            append(addFilesElement, group);
            this._chatEditsActionsDisposables.add(toDisposable(() => {
                group.remove();
            }));
        }
    }
    async renderFollowups(items, response) {
        if (!this.options.renderFollowups) {
            return;
        }
        this.followupsDisposables.clear();
        clearNode(this.followupsContainer);
        if (items && items.length > 0) {
            this.followupsDisposables.add(this.instantiationService.createInstance(ChatFollowups, this.followupsContainer, items, this.location, undefined, followup => this._onDidAcceptFollowup.fire({ followup, response })));
        }
        this._onDidChangeHeight.fire();
    }
    get contentHeight() {
        const data = this.getLayoutData();
        return data.followupsHeight + data.inputPartEditorHeight + data.inputPartVerticalPadding + data.inputEditorBorder + data.attachmentsHeight + data.toolbarsHeight + data.chatEditingStateHeight;
    }
    layout(height, width) {
        this.cachedDimensions = new Dimension(width, height);
        return this._layout(height, width);
    }
    _layout(height, width, allowRecurse = true) {
        const data = this.getLayoutData();
        const inputEditorHeight = Math.min(data.inputPartEditorHeight, height - data.followupsHeight - data.attachmentsHeight - data.inputPartVerticalPadding - data.toolbarsHeight);
        const followupsWidth = width - data.inputPartHorizontalPadding;
        this.followupsContainer.style.width = `${followupsWidth}px`;
        this._inputPartHeight = data.inputPartVerticalPadding + data.followupsHeight + inputEditorHeight + data.inputEditorBorder + data.attachmentsHeight + data.toolbarsHeight + data.chatEditingStateHeight;
        this._followupsHeight = data.followupsHeight;
        this._editSessionWidgetHeight = data.chatEditingStateHeight;
        const initialEditorScrollWidth = this._inputEditor.getScrollWidth();
        const newEditorWidth = width - data.inputPartHorizontalPadding - data.editorBorder - data.inputPartHorizontalPaddingInside - data.toolbarsWidth - data.sideToolbarWidth;
        const newDimension = { width: newEditorWidth, height: inputEditorHeight };
        if (!this.previousInputEditorDimension || (this.previousInputEditorDimension.width !== newDimension.width || this.previousInputEditorDimension.height !== newDimension.height)) {
            this._inputEditor.layout(newDimension);
            this.previousInputEditorDimension = newDimension;
        }
        if (allowRecurse && initialEditorScrollWidth < 10) {
            return this._layout(height, width, false);
        }
    }
    getLayoutData() {
        const executeToolbarWidth = this.cachedExecuteToolbarWidth = this.executeToolbar.getItemsWidth();
        const inputToolbarWidth = this.cachedInputToolbarWidth = this.inputActionsToolbar.getItemsWidth();
        const executeToolbarPadding = (this.executeToolbar.getItemsLength() - 1) * 4;
        const inputToolbarPadding = this.inputActionsToolbar.getItemsLength() ? (this.inputActionsToolbar.getItemsLength() - 1) * 4 : 0;
        return {
            inputEditorBorder: 2,
            followupsHeight: this.followupsContainer.offsetHeight,
            inputPartEditorHeight: Math.min(this._inputEditor.getContentHeight(), this.inputEditorMaxHeight),
            inputPartHorizontalPadding: this.options.renderStyle === 'compact' ? 16 : 32,
            inputPartVerticalPadding: this.options.renderStyle === 'compact' ? 12 : 28,
            attachmentsHeight: this.attachedContextContainer.offsetHeight,
            editorBorder: 2,
            inputPartHorizontalPaddingInside: 12,
            toolbarsWidth: this.options.renderStyle === 'compact' ? executeToolbarWidth + executeToolbarPadding + inputToolbarWidth + inputToolbarPadding : 0,
            toolbarsHeight: this.options.renderStyle === 'compact' ? 0 : 22,
            chatEditingStateHeight: this.chatEditingSessionWidgetContainer.offsetHeight,
            sideToolbarWidth: this.inputSideToolbarContainer ? getTotalWidth(this.inputSideToolbarContainer) + 4  : 0,
        };
    }
    getViewState() {
        return this.getInputState();
    }
    saveState() {
        this.saveCurrentValue(this.getInputState());
        const inputHistory = [...this.history];
        this.historyService.saveHistory(this.location, inputHistory);
    }
};
ChatInputPart = ChatInputPart_1 = ( __decorate([
    ( __param(4, IChatWidgetHistoryService)),
    ( __param(5, IModelService)),
    ( __param(6, ILanguageService)),
    ( __param(7, IInstantiationService)),
    ( __param(8, IContextKeyService)),
    ( __param(9, IConfigurationService)),
    ( __param(10, IKeybindingService)),
    ( __param(11, IAccessibilityService)),
    ( __param(12, ILanguageModelsService)),
    ( __param(13, ILogService)),
    ( __param(14, IHoverService)),
    ( __param(15, IFileService)),
    ( __param(16, ICommandService)),
    ( __param(17, IEditorService)),
    ( __param(18, IOpenerService)),
    ( __param(19, IChatEditingService)),
    ( __param(20, IThemeService)),
    ( __param(21, ITextModelService)),
    ( __param(22, IStorageService)),
    ( __param(23, ILabelService)),
    ( __param(24, IChatVariablesService)),
    ( __param(25, IChatAgentService))
], ChatInputPart));
const historyKeyFn = (entry) => JSON.stringify(entry);
function getLastPosition(model) {
    return { lineNumber: model.getLineCount(), column: model.getLineLength(model.getLineCount()) + 1 };
}
let ChatSubmitDropdownActionItem = class ChatSubmitDropdownActionItem extends DropdownWithPrimaryActionViewItem {
    constructor(action, dropdownAction, options, menuService, contextMenuService, chatAgentService, contextKeyService, keybindingService, notificationService, themeService, accessibilityService) {
        super(action, dropdownAction, [], '', {
            ...options,
            getKeyBinding: (action) => keybindingService.lookupKeybinding(action.id, contextKeyService)
        }, contextMenuService, keybindingService, notificationService, contextKeyService, themeService, accessibilityService);
        const menu = menuService.createMenu(MenuId.ChatExecuteSecondary, contextKeyService);
        const setActions = () => {
            const secondary = getFlatActionBarActions(menu.getActions({ shouldForwardArgs: true }));
            const secondaryAgent = chatAgentService.getSecondaryAgent();
            if (secondaryAgent) {
                secondary.forEach(a => {
                    if (a.id === ChatSubmitSecondaryAgentAction.ID) {
                        a.label = ( localize(4567, "Send to @{0}", secondaryAgent.name));
                    }
                    return a;
                });
            }
            this.update(dropdownAction, secondary);
        };
        setActions();
        this._register(menu.onDidChange(() => setActions()));
    }
};
ChatSubmitDropdownActionItem = ( __decorate([
    ( __param(3, IMenuService)),
    ( __param(4, IContextMenuService)),
    ( __param(5, IChatAgentService)),
    ( __param(6, IContextKeyService)),
    ( __param(7, IKeybindingService)),
    ( __param(8, INotificationService)),
    ( __param(9, IThemeService)),
    ( __param(10, IAccessibilityService))
], ChatSubmitDropdownActionItem));
let ModelPickerActionViewItem = class ModelPickerActionViewItem extends MenuEntryActionViewItem {
    constructor(action, currentLanguageModel, delegate, options, keybindingService, notificationService, contextKeyService, themeService, contextMenuService, _accessibilityService, _commandService) {
        super(action, options, keybindingService, notificationService, contextKeyService, themeService, contextMenuService, _accessibilityService);
        this.currentLanguageModel = currentLanguageModel;
        this.delegate = delegate;
        this._commandService = _commandService;
        this._register(delegate.onDidChangeModel(modelId => {
            this.currentLanguageModel = modelId;
            this.updateLabel();
        }));
    }
    async onClick(event) {
        this._openContextMenu();
    }
    render(container) {
        super.render(container);
        container.classList.add('chat-modelPicker-item');
        this._register(addDisposableListener(container, EventType.KEY_UP, e => {
            const event = ( new StandardKeyboardEvent(e));
            if (event.equals(KeyCode.Enter) || event.equals(KeyCode.Space)) {
                this._openContextMenu();
            }
        }));
    }
    updateLabel() {
        if (this.label && this.currentLanguageModel) {
            reset(this.label, $$1('span.chat-model-label', undefined, this.currentLanguageModel.metadata.name), ...renderLabelWithIcons(`$(chevron-down)`));
        }
    }
    _openContextMenu() {
        const setLanguageModelAction = (entry) => {
            return {
                id: entry.identifier,
                label: entry.metadata.name,
                tooltip: '',
                class: undefined,
                enabled: true,
                checked: entry.identifier === this.currentLanguageModel.identifier,
                run: () => {
                    this.currentLanguageModel = entry;
                    this.updateLabel();
                    this.delegate.setModel(entry);
                }
            };
        };
        const models = this.delegate.getModels();
        this._contextMenuService.showContextMenu({
            getAnchor: () => this.element,
            getActions: () => {
                const actions = ( models.map(entry => setLanguageModelAction(entry)));
                if (this._contextKeyService.getContextKeyValue(ChatContextKeys.Setup.limited.key) === true) {
                    actions.push(( new Separator()));
                    actions.push(toAction({ id: 'moreModels', label: ( localize(4568, "Enable More Models...")), run: () => this._commandService.executeCommand('workbench.action.chat.upgradePlan') }));
                }
                return actions;
            },
        });
    }
};
ModelPickerActionViewItem = ( __decorate([
    ( __param(4, IKeybindingService)),
    ( __param(5, INotificationService)),
    ( __param(6, IContextKeyService)),
    ( __param(7, IThemeService)),
    ( __param(8, IContextMenuService)),
    ( __param(9, IAccessibilityService)),
    ( __param(10, ICommandService))
], ModelPickerActionViewItem));
const chatInputEditorContainerSelector = '.interactive-input-editor';
setupSimpleEditorSelectionStyling(chatInputEditorContainerSelector);
let ToggleAgentActionViewItem = class ToggleAgentActionViewItem extends MenuEntryActionViewItem {
    constructor(action, options, keybindingService, notificationService, contextKeyService, themeService, contextMenuService, _accessibilityService) {
        options.keybindingNotRenderedWithLabel = true;
        super(action, options, keybindingService, notificationService, contextKeyService, themeService, contextMenuService, _accessibilityService);
        this.agentStateActions = [
            {
                ...this.action,
                id: 'agentMode',
                label: ( localize(4569, "Agent")),
                class: undefined,
                enabled: true,
                run: () => this.action.run({ agentMode: true })
            },
            {
                ...this.action,
                id: 'normalMode',
                label: ( localize(4570, "Edit")),
                class: undefined,
                enabled: true,
                checked: !this.action.checked,
                run: () => this.action.run({ agentMode: false })
            },
        ];
    }
    async onClick(event) {
        this._openContextMenu();
    }
    render(container) {
        super.render(container);
        container.classList.add('chat-modelPicker-item');
        this._register(addDisposableListener(container, EventType.KEY_UP, e => {
            const event = ( new StandardKeyboardEvent(e));
            if (event.equals(KeyCode.Enter) || event.equals(KeyCode.Space)) {
                this._openContextMenu();
            }
        }));
    }
    updateLabel() {
        if (this.label) {
            const state = this.agentStateActions.find(action => action.checked)?.label ?? '';
            reset(this.label, $$1('span.chat-model-label', undefined, state), ...renderLabelWithIcons(`$(chevron-down)`));
        }
    }
    _openContextMenu() {
        if (this.action.enabled) {
            this._contextMenuService.showContextMenu({
                getAnchor: () => this.element,
                getActions: () => this.agentStateActions
            });
        }
    }
};
ToggleAgentActionViewItem = ( __decorate([
    ( __param(2, IKeybindingService)),
    ( __param(3, INotificationService)),
    ( __param(4, IContextKeyService)),
    ( __param(5, IThemeService)),
    ( __param(6, IContextMenuService)),
    ( __param(7, IAccessibilityService))
], ToggleAgentActionViewItem));

export { ChatInputPart };
