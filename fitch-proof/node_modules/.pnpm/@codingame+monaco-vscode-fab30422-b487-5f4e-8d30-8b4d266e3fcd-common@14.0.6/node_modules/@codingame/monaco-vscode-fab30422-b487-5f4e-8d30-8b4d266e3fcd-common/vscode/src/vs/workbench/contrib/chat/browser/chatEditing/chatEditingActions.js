
import { CancellationToken } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { KeyMod, KeyCode } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { basename } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { isCodeEditor } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorBrowser';
import { Position } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/position';
import { EditorContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/editorContextKeys';
import { isLocation } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { ILanguageFeaturesService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/languageFeatures';
import { ITextModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/resolverService';
import { localize2, localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { Action2, registerAction2, MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { EditorActivation } from '@codingame/monaco-vscode-api/vscode/vs/platform/editor/common/editor';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { IListService } from '@codingame/monaco-vscode-api/vscode/vs/platform/list/browser/listService.service';
import { GroupsOrder } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService';
import { IEditorGroupsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { ChatContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatContextKeys';
import { chatEditingWidgetFileReadonlyContextKey, chatEditingAgentSupportsReadonlyReferencesContextKey, chatEditingWidgetFileStateContextKey, WorkingSetEntryState, WorkingSetEntryRemovalReason, CHAT_EDITING_MULTI_DIFF_SOURCE_RESOLVER_SCHEME, chatEditingResourceContextKey, decidedChatEditingResourceContextKey, applyingChatEditsFailedContextKey, hasUndecidedChatEditingResourceContextKey, hasAppliedChatEditsContextKey } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService.service';
import { IChatService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatService.service';
import { isResponseVM, isRequestVM } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatViewModel';
import { CHAT_CATEGORY } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/actions/chatActions';
import { IChatWidgetService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat.service';

class WorkingSetAction extends Action2 {
    run(accessor, ...args) {
        const chatEditingService = accessor.get(IChatEditingService);
        const currentEditingSession = chatEditingService.currentEditingSession;
        if (!currentEditingSession) {
            return;
        }
        const chatWidget = accessor.get(IChatWidgetService).lastFocusedWidget;
        if (chatWidget?.location !== ChatAgentLocation.EditingSession) {
            return;
        }
        const uris = [];
        if (URI.isUri(args[0])) {
            uris.push(args[0]);
        }
        else if (chatWidget) {
            uris.push(...chatWidget.input.selectedElements);
        }
        if (!uris.length) {
            return;
        }
        return this.runWorkingSetAction(accessor, currentEditingSession, chatWidget, ...uris);
    }
}
registerAction2(class MarkFileAsReadonly extends WorkingSetAction {
    constructor() {
        super({
            id: 'chatEditing.markFileAsReadonly',
            title: ( localize2(4465, 'Mark as read-only')),
            icon: Codicon.lock,
            toggled: chatEditingWidgetFileReadonlyContextKey,
            menu: [{
                    id: MenuId.ChatEditingWidgetModifiedFilesToolbar,
                    when: ( ContextKeyExpr.and(chatEditingAgentSupportsReadonlyReferencesContextKey, ( ContextKeyExpr.or(( ContextKeyExpr.equals(chatEditingWidgetFileReadonlyContextKey.key, true)), ( ContextKeyExpr.equals(chatEditingWidgetFileReadonlyContextKey.key, false)))))),
                    order: 10,
                    group: 'navigation'
                }],
        });
    }
    async runWorkingSetAction(_accessor, currentEditingSession, _chatWidget, ...uris) {
        for (const uri of uris) {
            currentEditingSession.markIsReadonly(uri);
        }
    }
});
registerAction2(class AddFileToWorkingSet extends WorkingSetAction {
    constructor() {
        super({
            id: 'chatEditing.addFileToWorkingSet',
            title: ( localize2(4466, 'Add File')),
            icon: Codicon.plus,
            menu: [{
                    id: MenuId.ChatEditingWidgetModifiedFilesToolbar,
                    when: ( ContextKeyExpr.or(( ContextKeyExpr.equals(chatEditingWidgetFileStateContextKey.key, WorkingSetEntryState.Transient)), ( ContextKeyExpr.equals(chatEditingWidgetFileStateContextKey.key, WorkingSetEntryState.Suggested)))),
                    order: 0,
                    group: 'navigation'
                }],
        });
    }
    async runWorkingSetAction(_accessor, currentEditingSession, _chatWidget, ...uris) {
        for (const uri of uris) {
            currentEditingSession.addFileToWorkingSet(uri);
        }
    }
});
registerAction2(class RemoveFileFromWorkingSet extends WorkingSetAction {
    constructor() {
        super({
            id: 'chatEditing.removeFileFromWorkingSet',
            title: ( localize2(4467, 'Remove File')),
            icon: Codicon.close,
            menu: [{
                    id: MenuId.ChatEditingWidgetModifiedFilesToolbar,
                    order: 5,
                    group: 'navigation'
                }],
        });
    }
    async runWorkingSetAction(accessor, currentEditingSession, chatWidget, ...uris) {
        const dialogService = accessor.get(IDialogService);
        const pendingEntries = currentEditingSession.entries.get().filter((entry) => uris.includes(entry.modifiedURI) && entry.state.get() === WorkingSetEntryState.Modified);
        if (pendingEntries.length > 0) {
            const file = pendingEntries.length > 1
                ? ( localize(4468, "{0} files", pendingEntries.length))
                : basename(pendingEntries[0].modifiedURI);
            const confirmation = await dialogService.confirm({
                title: ( localize(4469, "Remove {0} from working set?", file)),
                message: ( localize(
                    4470,
                    "This will remove {0} from your working set and undo the edits made to it. Do you want to proceed?",
                    file
                )),
                primaryButton: ( localize(4471, "Yes")),
                type: 'info'
            });
            if (!confirmation.confirmed) {
                return;
            }
        }
        await currentEditingSession.reject(...uris);
        currentEditingSession.remove(WorkingSetEntryRemovalReason.User, ...uris);
        for (const uri of uris) {
            chatWidget.attachmentModel.delete(( uri.toString()));
        }
        const entries = [...currentEditingSession.workingSet.entries()];
        const suggestedFiles = entries.filter(([_, state]) => state.state === WorkingSetEntryState.Suggested);
        if (suggestedFiles.length === entries.length && !chatWidget.attachmentModel.attachments.find((v) => v.isFile && URI.isUri(v.value))) {
            currentEditingSession.remove(WorkingSetEntryRemovalReason.Programmatic, ...( entries.map(([uri,]) => uri)));
        }
    }
});
registerAction2(class OpenFileInDiffAction extends WorkingSetAction {
    constructor() {
        super({
            id: 'chatEditing.openFileInDiff',
            title: ( localize2(4472, 'Open Changes in Diff Editor')),
            icon: Codicon.diffSingle,
            menu: [{
                    id: MenuId.ChatEditingWidgetModifiedFilesToolbar,
                    when: ( ContextKeyExpr.equals(chatEditingWidgetFileStateContextKey.key, WorkingSetEntryState.Modified)),
                    order: 2,
                    group: 'navigation'
                }],
        });
    }
    async runWorkingSetAction(accessor, currentEditingSession, _chatWidget, ...uris) {
        const editorService = accessor.get(IEditorService);
        for (const uri of uris) {
            const editedFile = currentEditingSession.getEntry(uri);
            if (editedFile?.state.get() === WorkingSetEntryState.Modified) {
                await editorService.openEditor({
                    original: { resource: ( URI.from(editedFile.originalURI, true)) },
                    modified: { resource: ( URI.from(editedFile.modifiedURI, true)) },
                });
            }
            else {
                await editorService.openEditor({ resource: uri });
            }
        }
    }
});
registerAction2(class AcceptAction extends WorkingSetAction {
    constructor() {
        super({
            id: 'chatEditing.acceptFile',
            title: ( localize2(4473, 'Accept')),
            icon: Codicon.check,
            menu: [{
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('resourceScheme', CHAT_EDITING_MULTI_DIFF_SOURCE_RESOLVER_SCHEME)), ContextKeyExpr.notIn(chatEditingResourceContextKey.key, decidedChatEditingResourceContextKey.key))),
                    id: MenuId.MultiDiffEditorFileToolbar,
                    order: 0,
                    group: 'navigation',
                }, {
                    id: MenuId.ChatEditingWidgetModifiedFilesToolbar,
                    when: ( ContextKeyExpr.equals(chatEditingWidgetFileStateContextKey.key, WorkingSetEntryState.Modified)),
                    order: 0,
                    group: 'navigation'
                }],
        });
    }
    async runWorkingSetAction(accessor, currentEditingSession, chatWidget, ...uris) {
        await currentEditingSession.accept(...uris);
    }
});
registerAction2(class DiscardAction extends WorkingSetAction {
    constructor() {
        super({
            id: 'chatEditing.discardFile',
            title: ( localize2(4474, 'Discard')),
            icon: Codicon.discard,
            menu: [{
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('resourceScheme', CHAT_EDITING_MULTI_DIFF_SOURCE_RESOLVER_SCHEME)), ContextKeyExpr.notIn(chatEditingResourceContextKey.key, decidedChatEditingResourceContextKey.key))),
                    id: MenuId.MultiDiffEditorFileToolbar,
                    order: 2,
                    group: 'navigation',
                }, {
                    id: MenuId.ChatEditingWidgetModifiedFilesToolbar,
                    when: ( ContextKeyExpr.equals(chatEditingWidgetFileStateContextKey.key, WorkingSetEntryState.Modified)),
                    order: 1,
                    group: 'navigation'
                }],
        });
    }
    async runWorkingSetAction(accessor, currentEditingSession, chatWidget, ...uris) {
        await currentEditingSession.reject(...uris);
    }
});
class ChatEditingAcceptAllAction extends Action2 {
    constructor() {
        super({
            id: 'chatEditing.acceptAllFiles',
            title: ( localize(4475, 'Accept')),
            icon: Codicon.check,
            tooltip: ( localize(4476, 'Accept All Edits')),
            precondition: ( ContextKeyExpr.and(( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey)),
            keybinding: {
                primary: KeyMod.CtrlCmd | KeyCode.Enter,
                when: ( ContextKeyExpr.and(( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ChatContextKeys.inChatInput)),
                weight: KeybindingWeight.WorkbenchContrib,
            },
            menu: [
                {
                    when: ( ContextKeyExpr.equals('resourceScheme', CHAT_EDITING_MULTI_DIFF_SOURCE_RESOLVER_SCHEME)),
                    id: MenuId.EditorTitle,
                    order: 0,
                    group: 'navigation',
                },
                {
                    id: MenuId.ChatEditingWidgetToolbar,
                    group: 'navigation',
                    order: 0,
                    when: ( ContextKeyExpr.and(( applyingChatEditsFailedContextKey.negate()), ( ContextKeyExpr.and(hasUndecidedChatEditingResourceContextKey, ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))))))))
                }
            ]
        });
    }
    async run(accessor, ...args) {
        const chatEditingService = accessor.get(IChatEditingService);
        const currentEditingSession = chatEditingService.currentEditingSession;
        if (!currentEditingSession) {
            return;
        }
        await currentEditingSession.accept();
    }
}
registerAction2(ChatEditingAcceptAllAction);
class ChatEditingDiscardAllAction extends Action2 {
    constructor() {
        super({
            id: 'chatEditing.discardAllFiles',
            title: ( localize(4477, 'Discard')),
            icon: Codicon.discard,
            tooltip: ( localize(4478, 'Discard All Edits')),
            precondition: ( ContextKeyExpr.and(( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey)),
            menu: [
                {
                    when: ( ContextKeyExpr.equals('resourceScheme', CHAT_EDITING_MULTI_DIFF_SOURCE_RESOLVER_SCHEME)),
                    id: MenuId.EditorTitle,
                    order: 1,
                    group: 'navigation',
                },
                {
                    id: MenuId.ChatEditingWidgetToolbar,
                    group: 'navigation',
                    order: 1,
                    when: ( ContextKeyExpr.and(( applyingChatEditsFailedContextKey.negate()), ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), hasUndecidedChatEditingResourceContextKey))))
                }
            ],
            keybinding: {
                when: ( ContextKeyExpr.and(( ChatContextKeys.requestInProgress.negate()), hasUndecidedChatEditingResourceContextKey, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ChatContextKeys.inChatInput, ( ChatContextKeys.inputHasText.negate()))),
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.CtrlCmd | KeyCode.Backspace,
            },
        });
    }
    async run(accessor, ...args) {
        await discardAllEditsWithConfirmation(accessor);
    }
}
registerAction2(ChatEditingDiscardAllAction);
async function discardAllEditsWithConfirmation(accessor) {
    const chatEditingService = accessor.get(IChatEditingService);
    const dialogService = accessor.get(IDialogService);
    const currentEditingSession = chatEditingService.currentEditingSession;
    if (!currentEditingSession) {
        return false;
    }
    const entries = currentEditingSession.entries.get();
    if (entries.length > 0) {
        const confirmation = await dialogService.confirm({
            title: ( localize(4479, "Discard all edits?")),
            message: entries.length === 1
                ? ( localize(
                4480,
                "This will undo changes made by {0} in {1}. Do you want to proceed?",
                'Copilot Edits',
                basename(entries[0].modifiedURI)
            ))
                : ( localize(
                4481,
                "This will undo changes made by {0} in {1} files. Do you want to proceed?",
                'Copilot Edits',
                entries.length
            )),
            primaryButton: ( localize(4482, "Yes")),
            type: 'info'
        });
        if (!confirmation.confirmed) {
            return false;
        }
    }
    await currentEditingSession.reject();
    return true;
}
class ChatEditingRemoveAllFilesAction extends Action2 {
    static { this.ID = 'chatEditing.clearWorkingSet'; }
    constructor() {
        super({
            id: ChatEditingRemoveAllFilesAction.ID,
            title: ( localize(4483, 'Clear Working Set')),
            icon: Codicon.clearAll,
            tooltip: ( localize(4483, 'Clear Working Set')),
            precondition: ( ContextKeyExpr.and(( ChatContextKeys.requestInProgress.negate()))),
            menu: [
                {
                    id: MenuId.ChatEditingWidgetToolbar,
                    group: 'navigation',
                    order: 5,
                    when: ( ContextKeyExpr.and(( hasAppliedChatEditsContextKey.negate()), ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))))
                }
            ]
        });
    }
    async run(accessor, ...args) {
        const chatEditingService = accessor.get(IChatEditingService);
        const currentEditingSession = chatEditingService.currentEditingSession;
        if (!currentEditingSession) {
            return;
        }
        const chatWidget = accessor.get(IChatWidgetService).getWidgetBySessionId(currentEditingSession.chatSessionId);
        const uris = [...( currentEditingSession.workingSet.keys())];
        currentEditingSession.remove(WorkingSetEntryRemovalReason.User, ...uris);
        const attachmentModel = chatWidget?.attachmentModel;
        const fileAttachments = attachmentModel ? [...attachmentModel.excludedFileAttachments, ...attachmentModel.fileAttachments] : [];
        const attachmentIdsToRemove = ( fileAttachments.map(attachment => ( attachment.value.toString())));
        chatWidget?.attachmentModel.delete(...attachmentIdsToRemove);
    }
}
registerAction2(ChatEditingRemoveAllFilesAction);
class ChatEditingShowChangesAction extends Action2 {
    static { this.ID = 'chatEditing.viewChanges'; }
    static { this.LABEL = ( localize(4484, 'View All Edits')); }
    constructor() {
        super({
            id: ChatEditingShowChangesAction.ID,
            title: ChatEditingShowChangesAction.LABEL,
            tooltip: ChatEditingShowChangesAction.LABEL,
            f1: false,
            icon: Codicon.diffMultiple,
            precondition: hasUndecidedChatEditingResourceContextKey,
            menu: [
                {
                    id: MenuId.ChatEditingWidgetToolbar,
                    group: 'navigation',
                    order: 4,
                    when: ( ContextKeyExpr.and(( applyingChatEditsFailedContextKey.negate()), ( ContextKeyExpr.and(
                        hasAppliedChatEditsContextKey,
                        hasUndecidedChatEditingResourceContextKey,
                        ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))
                    ))))
                }
            ],
        });
    }
    async run(accessor, ...args) {
        const chatEditingService = accessor.get(IChatEditingService);
        const currentEditingSession = chatEditingService.currentEditingSession;
        if (!currentEditingSession) {
            return;
        }
        await currentEditingSession.show();
    }
}
registerAction2(ChatEditingShowChangesAction);
registerAction2(class AddFilesToWorkingSetAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.addSelectedFilesToWorkingSet',
            title: ( localize2(4485, "Add Selected Files to Working Set")),
            icon: Codicon.attach,
            category: CHAT_CATEGORY,
            precondition: ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)),
            f1: true
        });
    }
    async run(accessor, ...args) {
        const listService = accessor.get(IListService);
        const chatEditingService = accessor.get(IChatEditingService);
        const editorGroupService = accessor.get(IEditorGroupsService);
        const uris = [];
        for (const group of editorGroupService.getGroups(GroupsOrder.MOST_RECENTLY_ACTIVE)) {
            for (const selection of group.selectedEditors) {
                if (selection.resource) {
                    uris.push(selection.resource);
                }
            }
        }
        if (uris.length === 0) {
            const selection = listService.lastFocusedList?.getSelection();
            if (selection?.length) {
                for (const file of selection) {
                    if (!!file && typeof file === 'object' && 'resource' in file && URI.isUri(file.resource)) {
                        uris.push(file.resource);
                    }
                }
            }
        }
        for (const file of uris) {
            chatEditingService?.currentEditingSessionObs.get()?.addFileToWorkingSet(file);
        }
    }
});
registerAction2(class RemoveAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.chat.undoEdits',
            title: ( localize2(4486, "Undo Edits")),
            f1: false,
            category: CHAT_CATEGORY,
            icon: Codicon.x,
            keybinding: {
                primary: KeyCode.Delete,
                mac: {
                    primary: KeyMod.CtrlCmd | KeyCode.Backspace,
                },
                when: ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ChatContextKeys.inChatSession, ( ChatContextKeys.inChatInput.negate()))),
                weight: KeybindingWeight.WorkbenchContrib,
            },
            menu: [
                {
                    id: MenuId.ChatMessageTitle,
                    group: 'navigation',
                    order: 2,
                    when: ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), ChatContextKeys.isRequest))
                }
            ]
        });
    }
    async run(accessor, ...args) {
        let item = args[0];
        if (!isResponseVM(item) && !isRequestVM(item)) {
            const chatWidgetService = accessor.get(IChatWidgetService);
            const widget = chatWidgetService.lastFocusedWidget;
            item = widget?.getFocus();
        }
        if (!item) {
            return;
        }
        const configurationService = accessor.get(IConfigurationService);
        const dialogService = accessor.get(IDialogService);
        const chatEditingService = accessor.get(IChatEditingService);
        const chatService = accessor.get(IChatService);
        const chatModel = chatService.getSession(item.sessionId);
        if (chatModel?.initialLocation !== ChatAgentLocation.EditingSession) {
            return;
        }
        const session = chatEditingService.currentEditingSession;
        if (!session) {
            return;
        }
        const requestId = isRequestVM(item) ? item.id :
            isResponseVM(item) ? item.requestId : undefined;
        if (requestId) {
            const chatRequests = chatModel.getRequests();
            const itemIndex = chatRequests.findIndex(request => request.id === requestId);
            const editsToUndo = chatRequests.length - itemIndex;
            const requestsToRemove = chatRequests.slice(itemIndex);
            const requestIdsToRemove = ( new Set(( requestsToRemove.map(request => request.id))));
            const entriesModifiedInRequestsToRemove = chatEditingService.currentEditingSessionObs.get()?.entries.get().filter((entry) => ( requestIdsToRemove.has(entry.lastModifyingRequestId))) ?? [];
            const shouldPrompt = entriesModifiedInRequestsToRemove.length > 0 && configurationService.getValue('chat.editing.confirmEditRequestRemoval') === true;
            let message;
            if (editsToUndo === 1) {
                if (entriesModifiedInRequestsToRemove.length === 1) {
                    message = ( localize(
                        4487,
                        "This will remove your last request and undo the edits made to {0}. Do you want to proceed?",
                        basename(entriesModifiedInRequestsToRemove[0].modifiedURI)
                    ));
                }
                else {
                    message = ( localize(
                        4488,
                        "This will remove your last request and undo edits made to {0} files in your working set. Do you want to proceed?",
                        entriesModifiedInRequestsToRemove.length
                    ));
                }
            }
            else {
                if (entriesModifiedInRequestsToRemove.length === 1) {
                    message = ( localize(
                        4489,
                        "This will remove all subsequent requests and undo edits made to {0}. Do you want to proceed?",
                        basename(entriesModifiedInRequestsToRemove[0].modifiedURI)
                    ));
                }
                else {
                    message = ( localize(
                        4490,
                        "This will remove all subsequent requests and undo edits made to {0} files in your working set. Do you want to proceed?",
                        entriesModifiedInRequestsToRemove.length
                    ));
                }
            }
            const confirmation = shouldPrompt
                ? await dialogService.confirm({
                    title: editsToUndo === 1
                        ? ( localize(4491, "Do you want to undo your last edit?"))
                        : ( localize(4492, "Do you want to undo {0} edits?", editsToUndo)),
                    message: message,
                    primaryButton: ( localize(4493, "Yes")),
                    checkbox: { label: ( localize(4494, "Don't ask again")), checked: false },
                    type: 'info'
                })
                : { confirmed: true };
            if (!confirmation.confirmed) {
                return;
            }
            if (confirmation.checkboxChecked) {
                await configurationService.updateValue('chat.editing.confirmEditRequestRemoval', false);
            }
            const snapshotRequestId = chatRequests[itemIndex].id;
            await session.restoreSnapshot(snapshotRequestId);
            for (const request of requestsToRemove) {
                await chatService.removeRequest(item.sessionId, request.id);
            }
        }
    }
});
registerAction2(class OpenWorkingSetHistoryAction extends Action2 {
    static { this.id = 'chat.openFileSnapshot'; }
    constructor() {
        super({
            id: OpenWorkingSetHistoryAction.id,
            title: ( localize(4495, "Open File Snapshot")),
            precondition: ContextKeyExpr.notIn(ChatContextKeys.itemId.key, ChatContextKeys.lastItemId.key),
            menu: [{
                    id: MenuId.ChatEditingCodeBlockContext,
                    group: 'navigation',
                    order: 0,
                },]
        });
    }
    async run(accessor, ...args) {
        const context = args[0];
        if (!context?.sessionId) {
            return;
        }
        const chatService = accessor.get(IChatService);
        const chatEditingService = accessor.get(IChatEditingService);
        const editorService = accessor.get(IEditorService);
        const chatModel = chatService.getSession(context.sessionId);
        const requests = chatModel?.getRequests();
        if (!requests) {
            return;
        }
        const snapshotRequestIndex = requests?.findIndex((v, i) => i > 0 && requests[i - 1]?.id === context.requestId);
        if (snapshotRequestIndex < 1) {
            return;
        }
        const snapshotRequestId = requests[snapshotRequestIndex]?.id;
        if (snapshotRequestId) {
            const snapshot = chatEditingService.currentEditingSession?.getSnapshotUri(snapshotRequestId, context.uri);
            if (snapshot) {
                const editor = await editorService.openEditor({ resource: snapshot, label: ( localize(
                    4496,
                    '{0} (Snapshot {1})',
                    basename(context.uri),
                    snapshotRequestIndex - 1
                )), options: { transient: true, activation: EditorActivation.ACTIVATE } });
                if (isCodeEditor(editor)) {
                    editor.updateOptions({ readOnly: true });
                }
            }
        }
    }
});
registerAction2(class ResolveSymbolsContextAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.edits.addFilesFromReferences',
            title: ( localize2(4497, "Add Files From References")),
            f1: false,
            category: CHAT_CATEGORY,
            menu: {
                id: MenuId.ChatInputSymbolAttachmentContext,
                group: 'navigation',
                order: 1,
                when: ( ContextKeyExpr.and(( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)), EditorContextKeys.hasReferenceProvider))
            }
        });
    }
    async run(accessor, ...args) {
        const widgetService = accessor.get(IChatWidgetService);
        const textModelService = accessor.get(ITextModelService);
        const languageFeaturesService = accessor.get(ILanguageFeaturesService);
        const [widget] = widgetService.getWidgetsByLocations(ChatAgentLocation.EditingSession);
        if (!widget || args.length === 0 || !isLocation(args[0])) {
            return;
        }
        const symbol = args[0];
        const modelReference = await textModelService.createModelReference(symbol.uri);
        const textModel = modelReference.object.textEditorModel;
        if (!textModel) {
            return;
        }
        const position = ( new Position(symbol.range.startLineNumber, symbol.range.startColumn));
        const [references, definitions, implementations] = await Promise.all([
            this.getReferences(position, textModel, languageFeaturesService),
            this.getDefinitions(position, textModel, languageFeaturesService),
            this.getImplementations(position, textModel, languageFeaturesService)
        ]);
        const attachments = [];
        for (const reference of [...definitions, ...implementations, ...references]) {
            attachments.push(widget.attachmentModel.asVariableEntry(reference.uri));
        }
        widget.attachmentModel.addContext(...attachments);
    }
    async getReferences(position, textModel, languageFeaturesService) {
        const referenceProviders = languageFeaturesService.referenceProvider.all(textModel);
        const references = await Promise.all(( referenceProviders.map(async (referenceProvider) => {
            return (await referenceProvider.provideReferences(textModel, position, { includeDeclaration: true }, CancellationToken.None)) ?? [];
        })));
        return references.flat();
    }
    async getDefinitions(position, textModel, languageFeaturesService) {
        const definitionProviders = languageFeaturesService.definitionProvider.all(textModel);
        const definitions = await Promise.all(( definitionProviders.map(async (definitionProvider) => {
            return (await definitionProvider.provideDefinition(textModel, position, CancellationToken.None)) ?? [];
        })));
        return definitions.flat();
    }
    async getImplementations(position, textModel, languageFeaturesService) {
        const implementationProviders = languageFeaturesService.implementationProvider.all(textModel);
        const implementations = await Promise.all(( implementationProviders.map(async (implementationProvider) => {
            return (await implementationProvider.provideImplementation(textModel, position, CancellationToken.None)) ?? [];
        })));
        return implementations.flat();
    }
});

export { ChatEditingAcceptAllAction, ChatEditingDiscardAllAction, ChatEditingRemoveAllFilesAction, ChatEditingShowChangesAction, discardAllEditsWithConfirmation };
