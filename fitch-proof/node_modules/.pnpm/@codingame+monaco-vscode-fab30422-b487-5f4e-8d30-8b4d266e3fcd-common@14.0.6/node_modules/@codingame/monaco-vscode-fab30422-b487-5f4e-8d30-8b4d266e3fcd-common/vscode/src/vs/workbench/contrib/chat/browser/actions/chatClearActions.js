
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { KeyMod, KeyCode } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { localize2, localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { AccessibilitySignal } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibilitySignal/browser/accessibilitySignalService';
import { IAccessibilitySignalService } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibilitySignal/browser/accessibilitySignalService.service';
import { registerAction2, Action2, MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { ActiveEditorContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/contextkeys';
import { IViewsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/views/common/viewsService.service';
import { isChatViewTitleActionContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatActions';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatAgents';
import { ChatContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatContextKeys';
import { WorkingSetEntryState, hasUndecidedChatEditingResourceContextKey, hasAppliedChatEditsContextKey } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService.service';
import { ChatViewId, EditsViewId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat';
import { IChatWidgetService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat.service';
import { ctxIsGlobalEditingSession } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chatEditorController';
import { ChatEditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chatEditorInput';
import { CHAT_CATEGORY } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/actions/chatActions';
import { clearChatEditor } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/actions/chatClear';

const ACTION_ID_NEW_CHAT = `workbench.action.chat.newChat`;
const ACTION_ID_NEW_EDIT_SESSION = `workbench.action.chat.newEditSession`;
const ChatDoneActionId = 'workbench.action.chat.done';
function registerNewChatActions() {
    registerAction2(class NewChatEditorAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chatEditor.newChat',
                title: ( localize2(4261, "New Chat")),
                icon: Codicon.plus,
                f1: false,
                precondition: ChatContextKeys.enabled,
                menu: [{
                        id: MenuId.EditorTitle,
                        group: 'navigation',
                        order: 0,
                        when: ( ActiveEditorContext.isEqualTo(ChatEditorInput.EditorID)),
                    }]
            });
        }
        async run(accessor, ...args) {
            announceChatCleared(accessor.get(IAccessibilitySignalService));
            await clearChatEditor(accessor);
        }
    });
    registerAction2(class GlobalClearChatAction extends Action2 {
        constructor() {
            super({
                id: ACTION_ID_NEW_CHAT,
                title: ( localize2(4261, "New Chat")),
                category: CHAT_CATEGORY,
                icon: Codicon.plus,
                precondition: ( ContextKeyExpr.and(ChatContextKeys.enabled, ( ChatContextKeys.location.notEqualsTo(ChatAgentLocation.EditingSession)))),
                f1: true,
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod.CtrlCmd | KeyCode.KeyL,
                    mac: {
                        primary: KeyMod.WinCtrl | KeyCode.KeyL
                    },
                    when: ChatContextKeys.inChatSession
                },
                menu: [{
                        id: MenuId.ChatContext,
                        group: 'z_clear'
                    },
                    {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', ChatViewId)),
                        group: 'navigation',
                        order: -1
                    }]
            });
        }
        async run(accessor, ...args) {
            const context = args[0];
            const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
            const widgetService = accessor.get(IChatWidgetService);
            let widget = widgetService.lastFocusedWidget;
            if (isChatViewTitleActionContext(context)) {
                widget = widgetService.getWidgetBySessionId(context.sessionId);
            }
            if (widget) {
                announceChatCleared(accessibilitySignalService);
                widget.clear();
                widget.focusInput();
            }
        }
    });
    registerAction2(class NewEditSessionAction extends Action2 {
        constructor() {
            super({
                id: ACTION_ID_NEW_EDIT_SESSION,
                title: ( localize2(4262, "New Edit Session")),
                category: CHAT_CATEGORY,
                icon: Codicon.plus,
                precondition: ( ContextKeyExpr.and(ChatContextKeys.enabled, ChatContextKeys.editingParticipantRegistered)),
                f1: true,
                menu: [{
                        id: MenuId.ChatContext,
                        group: 'z_clear'
                    },
                    {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', EditsViewId)),
                        group: 'navigation',
                        order: -1
                    }],
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod.CtrlCmd | KeyCode.KeyL,
                    mac: {
                        primary: KeyMod.WinCtrl | KeyCode.KeyL
                    },
                    when: ( ContextKeyExpr.and(ChatContextKeys.inChatSession, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession))))
                }
            });
        }
        async _handleCurrentEditingSession(chatEditingService, dialogService) {
            const currentEditingSession = chatEditingService.currentEditingSessionObs.get();
            const currentEdits = currentEditingSession?.entries.get();
            const currentEditCount = currentEdits?.length;
            if (currentEditingSession && currentEditCount) {
                const undecidedEdits = currentEdits.filter((edit) => edit.state.get() === WorkingSetEntryState.Modified);
                if (undecidedEdits.length) {
                    const { result } = await dialogService.prompt({
                        title: ( localize(4263, "Start new editing session?")),
                        message: ( localize(
                            4264,
                            "Starting a new editing session will end your current session. Do you want to accept pending edits to {0} files?",
                            undecidedEdits.length
                        )),
                        type: 'info',
                        cancelButton: true,
                        buttons: [
                            {
                                label: ( localize(4265, "Accept & Continue")),
                                run: async () => {
                                    await currentEditingSession.accept();
                                    return true;
                                }
                            },
                            {
                                label: ( localize(4266, "Discard & Continue")),
                                run: async () => {
                                    await currentEditingSession.reject();
                                    return true;
                                }
                            }
                        ],
                    });
                    return Boolean(result);
                }
            }
            return true;
        }
        async run(accessor, ...args) {
            const context = args[0];
            const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
            const widgetService = accessor.get(IChatWidgetService);
            const chatEditingService = accessor.get(IChatEditingService);
            const dialogService = accessor.get(IDialogService);
            const viewsService = accessor.get(IViewsService);
            if (!(await this._handleCurrentEditingSession(chatEditingService, dialogService))) {
                return;
            }
            if (isChatViewTitleActionContext(context)) {
                announceChatCleared(accessibilitySignalService);
                const widget = widgetService.getWidgetBySessionId(context.sessionId);
                if (widget) {
                    await chatEditingService.currentEditingSessionObs.get()?.stop(true);
                    widget.clear();
                    widget.attachmentModel.clear();
                    widget.focusInput();
                }
            }
            else {
                const chatView = await viewsService.openView(EditsViewId);
                const widget = chatView.widget;
                announceChatCleared(accessibilitySignalService);
                await chatEditingService.currentEditingSessionObs.get()?.stop(true);
                widget.clear();
                widget.attachmentModel.clear();
                widget.focusInput();
            }
        }
    });
    registerAction2(class GlobalEditsDoneAction extends Action2 {
        constructor() {
            super({
                id: ChatDoneActionId,
                title: ( localize2(4267, "Done")),
                category: CHAT_CATEGORY,
                precondition: ( ContextKeyExpr.and(ChatContextKeys.enabled, ChatContextKeys.editingParticipantRegistered)),
                f1: false,
                menu: [{
                        id: MenuId.ChatEditingWidgetToolbar,
                        when: ( ContextKeyExpr.and(( hasUndecidedChatEditingResourceContextKey.negate()), hasAppliedChatEditsContextKey, ChatContextKeys.editingParticipantRegistered, ( ChatContextKeys.location.isEqualTo(ChatAgentLocation.EditingSession)))),
                        group: 'navigation',
                        order: 0
                    }]
            });
        }
        async run(accessor, ...args) {
            const context = args[0];
            const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
            const widgetService = accessor.get(IChatWidgetService);
            if (isChatViewTitleActionContext(context)) {
                announceChatCleared(accessibilitySignalService);
                const widget = widgetService.getWidgetBySessionId(context.sessionId);
                if (widget) {
                    widget.clear();
                    widget.attachmentModel.clear();
                    widget.focusInput();
                }
            }
            else {
                const viewsService = accessor.get(IViewsService);
                const chatView = await viewsService.openView(EditsViewId);
                const widget = chatView.widget;
                announceChatCleared(accessibilitySignalService);
                widget.clear();
                widget.attachmentModel.clear();
                widget.focusInput();
            }
        }
    });
    registerAction2(class UndoChatEditInteractionAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.undoEdit',
                title: ( localize2(4268, "Undo Last Edit")),
                category: CHAT_CATEGORY,
                icon: Codicon.discard,
                precondition: ( ContextKeyExpr.and(
                    ChatContextKeys.chatEditingCanUndo,
                    ChatContextKeys.enabled,
                    ChatContextKeys.editingParticipantRegistered
                )),
                f1: true,
                menu: [{
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', EditsViewId)),
                        group: 'navigation',
                        order: -3
                    }]
            });
        }
        async run(accessor, ...args) {
            const chatEditingService = accessor.get(IChatEditingService);
            const currentEditingSession = chatEditingService.currentEditingSession;
            if (!currentEditingSession) {
                return;
            }
            await currentEditingSession.undoInteraction();
        }
    });
    registerAction2(class RedoChatEditInteractionAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.redoEdit',
                title: ( localize2(4269, "Redo Last Edit")),
                category: CHAT_CATEGORY,
                icon: Codicon.redo,
                precondition: ( ContextKeyExpr.and(
                    ChatContextKeys.chatEditingCanRedo,
                    ChatContextKeys.enabled,
                    ChatContextKeys.editingParticipantRegistered
                )),
                f1: true,
                menu: [{
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.equals('view', EditsViewId)),
                        group: 'navigation',
                        order: -2
                    }]
            });
        }
        async run(accessor, ...args) {
            const chatEditingService = accessor.get(IChatEditingService);
            const currentEditingSession = chatEditingService.currentEditingSession;
            if (!currentEditingSession) {
                return;
            }
            await chatEditingService.currentEditingSession?.redoInteraction();
        }
    });
    registerAction2(class GlobalOpenEditsAction extends Action2 {
        constructor() {
            super({
                id: 'workbench.action.chat.openEditSession',
                title: ( localize2(4270, "Open {0}", 'Copilot Edits')),
                category: CHAT_CATEGORY,
                icon: Codicon.goToEditingSession,
                f1: true,
                menu: [{
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', ChatViewId)), ChatContextKeys.editingParticipantRegistered, ( ContextKeyExpr.equals(`view.${EditsViewId}.visible`, false)), ( ContextKeyExpr.or(( ContextKeyExpr.and(( ContextKeyExpr.equals(`workbench.panel.chat.defaultViewContainerLocation`, true)), ( ContextKeyExpr.equals(`workbench.panel.chatEditing.defaultViewContainerLocation`, false)))), ( ContextKeyExpr.and(( ContextKeyExpr.equals(`workbench.panel.chat.defaultViewContainerLocation`, false)), ( ContextKeyExpr.equals(`workbench.panel.chatEditing.defaultViewContainerLocation`, true)))))))),
                        group: 'navigation',
                        order: 1
                    }, {
                        id: MenuId.ChatCommandCenter,
                        group: 'a_open',
                        order: 2
                    }, {
                        id: MenuId.ChatEditingEditorContent,
                        when: ctxIsGlobalEditingSession,
                        group: 'navigate',
                        order: 4,
                    }],
                keybinding: {
                    weight: KeybindingWeight.WorkbenchContrib,
                    primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KeyI,
                    linux: {
                        primary: KeyMod.CtrlCmd | KeyMod.Alt | KeyMod.Shift | KeyCode.KeyI
                    },
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.notEquals('view', EditsViewId)), ChatContextKeys.editingParticipantRegistered))
                }
            });
        }
        async run(accessor, ...args) {
            const viewsService = accessor.get(IViewsService);
            const chatView = await viewsService.openView(EditsViewId);
            chatView.widget.focusInput();
        }
    });
}
function announceChatCleared(accessibilitySignalService) {
    accessibilitySignalService.playSignal(AccessibilitySignal.clear);
}

export { ACTION_ID_NEW_CHAT, ACTION_ID_NEW_EDIT_SESSION, ChatDoneActionId, registerNewChatActions };
