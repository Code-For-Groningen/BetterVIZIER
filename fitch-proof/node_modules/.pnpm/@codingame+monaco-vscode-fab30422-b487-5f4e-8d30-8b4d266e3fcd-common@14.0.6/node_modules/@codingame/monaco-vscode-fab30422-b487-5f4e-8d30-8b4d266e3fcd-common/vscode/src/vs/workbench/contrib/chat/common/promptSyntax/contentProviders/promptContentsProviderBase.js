
import { __decorate } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { assert } from '@codingame/monaco-vscode-api/vscode/vs/base/common/assert';
import { CancellationError } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { ObservableDisposable } from '../../../../../../base/common/observableDisposable.js';
import { ParseError, FailedToResolveContentsStream } from '../../promptFileReferenceErrors.js';
import { cancelPreviousCalls } from '../../../../../../base/common/decorators/cancelPreviousCalls.js';

const PROMPT_SNIPPET_FILE_EXTENSION = '.prompt.md';
class PromptContentsProviderBase extends ObservableDisposable {
    constructor() {
        super();
        this.onChangeEmitter = this._register(( new Emitter()));
        this.onContentChangedEmitter = this._register(( new Emitter()));
        this.onContentChanged = this.onContentChangedEmitter.event;
        this.onChangeEmitter.fire = this.onChangeEmitter.fire.bind(this.onChangeEmitter);
        this._register(this.onChangeEmitter.event(this.onContentsChanged, this));
    }
    onContentsChanged(event, cancellationToken) {
        const promise = (cancellationToken?.isCancellationRequested)
            ? Promise.reject(( new CancellationError()))
            : this.getContentsStream(event, cancellationToken);
        promise
            .then((stream) => {
            if (cancellationToken?.isCancellationRequested || this.disposed) {
                stream.destroy();
                throw ( new CancellationError());
            }
            this.onContentChangedEmitter.fire(stream);
        })
            .catch((error) => {
            if (error instanceof ParseError) {
                this.onContentChangedEmitter.fire(error);
                return;
            }
            this.onContentChangedEmitter.fire(( new FailedToResolveContentsStream(this.uri, error)));
        });
        return this;
    }
    start() {
        assert(!this.disposed, 'Cannot start contents provider that was already disposed.');
        this.onContentsChanged('full');
        return this;
    }
    isPromptSnippet() {
        return this.uri.path.endsWith(PROMPT_SNIPPET_FILE_EXTENSION);
    }
}
PromptContentsProviderBase.__decorator = ( __decorate([
    cancelPreviousCalls
], PromptContentsProviderBase.prototype, "onContentsChanged", null));

export { PROMPT_SNIPPET_FILE_EXTENSION, PromptContentsProviderBase };
