
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { basename } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatEditingService.service';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { ChatInstructionAttachmentsModel } from './chatAttachmentModel/chatInstructionAttachmentsModel.js';

let ChatAttachmentModel = class ChatAttachmentModel extends Disposable {
    constructor(initService) {
        super();
        this.initService = initService;
        this._attachments = ( new Map());
        this._onDidChangeContext = this._register(( new Emitter()));
        this.onDidChangeContext = this._onDidChangeContext.event;
        this.promptInstructions = this._register(this.initService.createInstance(ChatInstructionAttachmentsModel)).onUpdate(() => {
            this._onDidChangeContext.fire();
        });
    }
    get attachments() {
        return Array.from(( this._attachments.values()));
    }
    get size() {
        return this._attachments.size;
    }
    getAttachmentIDs() {
        return ( new Set(( this._attachments.keys())));
    }
    clear() {
        this._attachments.clear();
        this._onDidChangeContext.fire();
    }
    delete(...variableEntryIds) {
        for (const variableEntryId of variableEntryIds) {
            this._attachments.delete(variableEntryId);
        }
        this._onDidChangeContext.fire();
    }
    addFile(uri, range) {
        this.addContext(this.asVariableEntry(uri, range));
    }
    asVariableEntry(uri, range, isMarkedReadonly) {
        return {
            value: range ? { uri, range } : uri,
            id: ( uri.toString()) + (range?.toString() ?? ''),
            name: basename(uri),
            isFile: true,
            isDynamic: true,
            isMarkedReadonly,
        };
    }
    addContext(...attachments) {
        let hasAdded = false;
        for (const attachment of attachments) {
            if (!( this._attachments.has(attachment.id))) {
                this._attachments.set(attachment.id, attachment);
                hasAdded = true;
            }
        }
        if (hasAdded) {
            this._onDidChangeContext.fire();
        }
    }
    clearAndSetContext(...attachments) {
        this.clear();
        this.addContext(...attachments);
    }
};
ChatAttachmentModel = ( __decorate([
    ( __param(0, IInstantiationService))
], ChatAttachmentModel));
let EditsAttachmentModel = class EditsAttachmentModel extends ChatAttachmentModel {
    get fileAttachments() {
        return this.attachments.filter(attachment => attachment.isFile);
    }
    get excludedFileAttachments() {
        return this._excludedFileAttachments;
    }
    constructor(_chatEditingService, _initService) {
        super(_initService);
        this._chatEditingService = _chatEditingService;
        this._onFileLimitExceeded = this._register(( new Emitter()));
        this.onFileLimitExceeded = this._onFileLimitExceeded.event;
        this._excludedFileAttachments = [];
    }
    isExcludeFileAttachment(fileAttachmentId) {
        return ( this._excludedFileAttachments.some(attachment => attachment.id === fileAttachmentId));
    }
    addContext(...attachments) {
        const currentAttachmentIds = this.getAttachmentIDs();
        const fileAttachments = attachments.filter(attachment => attachment.isFile);
        const otherAttachments = attachments.filter(attachment => !attachment.isFile);
        const newFileAttachments = [];
        const newFileAttachmentIds = ( new Set());
        for (const attachment of fileAttachments) {
            if (( newFileAttachmentIds.has(attachment.id)) || ( currentAttachmentIds.has(attachment.id))) {
                continue;
            }
            newFileAttachmentIds.add(attachment.id);
            newFileAttachments.push(attachment);
        }
        const availableFileCount = Math.max(0, this._chatEditingService.editingSessionFileLimit - this.fileAttachments.length);
        const fileAttachmentsToBeAdded = newFileAttachments.slice(0, availableFileCount);
        if (newFileAttachments.length > availableFileCount) {
            const attachmentsExceedingSize = newFileAttachments.slice(availableFileCount).filter(attachment => !this.isExcludeFileAttachment(attachment.id));
            this._excludedFileAttachments.push(...attachmentsExceedingSize);
            this._onDidChangeContext.fire();
            this._onFileLimitExceeded.fire();
        }
        super.addContext(...otherAttachments, ...fileAttachmentsToBeAdded);
    }
    clear() {
        this._excludedFileAttachments.splice(0, this._excludedFileAttachments.length);
        super.clear();
    }
    delete(...variableEntryIds) {
        for (const variableEntryId of variableEntryIds) {
            const excludedFileIndex = this._excludedFileAttachments.findIndex(attachment => attachment.id === variableEntryId);
            if (excludedFileIndex !== -1) {
                this._excludedFileAttachments.splice(excludedFileIndex, 1);
            }
        }
        super.delete(...variableEntryIds);
        if (this.fileAttachments.length < this._chatEditingService.editingSessionFileLimit) {
            const availableFileCount = Math.max(0, this._chatEditingService.editingSessionFileLimit - this.fileAttachments.length);
            const reAddAttachments = this._excludedFileAttachments.splice(0, availableFileCount);
            super.addContext(...reAddAttachments);
        }
    }
};
EditsAttachmentModel = ( __decorate([
    ( __param(0, IChatEditingService)),
    ( __param(1, IInstantiationService))
], EditsAttachmentModel));

export { ChatAttachmentModel, EditsAttachmentModel };
